<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>wittleLuna&#39;s blog</title>
    <link>https://wittleLuna.github.io/en/post/</link>
    <description>Recent content from wittleLuna&#39;s blog</description>
    <generator>Hugo</generator>
    <language>en</language>
    
    <managingEditor>syaz23277@gmail.com (wittleLuna)</managingEditor>
    <webMaster>syaz23277@gmail.com (wittleLuna)</webMaster>
    
    <copyright>All articles on this blog are licensed under the BY-NC-SA license agreement unless otherwise stated. Please indicate the source when reprinting!</copyright>
    
    <lastBuildDate>Sat, 25 Oct 2025 17:41:41 +0800</lastBuildDate>
    
    
    <atom:link href="https://wittleLuna.github.io/en/post/index.xml" rel="self" type="application/rss&#43;xml" />
    

    
    

    <item>
      <title>Getting into Competitive Programming from Zero</title>
      <link>https://wittleLuna.github.io/en/post/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%A5%E5%9D%91%E7%BC%96%E7%A8%8B%E6%AF%94%E8%B5%9B/</link>
      <pubDate>Sat, 25 Oct 2025 00:00:00 &#43;0000</pubDate>
      <author>syaz23277@gmail.com (wittleLuna)</author>
      <guid>https://wittleLuna.github.io/en/post/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%A5%E5%9D%91%E7%BC%96%E7%A8%8B%E6%AF%94%E8%B5%9B/</guid>
      <description>
        <![CDATA[<h1>Getting into Competitive Programming from Zero</h1><p>Author: wittleLuna(syaz23277@gmail.com)</p>
        
          <h1 id="从零开始入坑编程比赛">
<a class="header-anchor" href="#%e4%bb%8e%e9%9b%b6%e5%bc%80%e5%a7%8b%e5%85%a5%e5%9d%91%e7%bc%96%e7%a8%8b%e6%af%94%e8%b5%9b"></a>
从零开始，入坑编程比赛
</h1><h2 id="1-什么是编程比赛">
<a class="header-anchor" href="#1-%e4%bb%80%e4%b9%88%e6%98%af%e7%bc%96%e7%a8%8b%e6%af%94%e8%b5%9b"></a>
1. 什么是编程比赛？
</h2><p>编程比赛，一般称为程序设计竞赛，要求选手在有限的时间内编写程序，分析和解决问题。</p>
<p>国内比较出名的比赛有：</p>
<ul>
<li>
<p>OI（Olympiad in Informatics，信息学奥林匹克竞赛），是高中五大学科竞赛之一。</p>
</li>
<li>
<p>ICPC（International Collegiate Programming Contest，国际大学生程序设计竞赛），由 ICPC 基金会（ICPC Foundation）举办，是最具影响力的大学生计算机竞赛。由于以前 ACM 赞助这个竞赛，也有很多人习惯叫它 ACM 竞赛。</p>
</li>
<li>
<p>蓝桥杯，由中华人民共和国工业和信息化部人才交流中心主办（据相关新闻，2026届起已与工信部脱钩），从中小学到大学高校一直备受青睐，是参加人数多，知名度较高的比赛之一。</p>
</li>
<li>
<p>码蹄杯，是由全国高等学校计算机教育研究会主办、清华大学出版社承办的编程竞赛，截至2025年举办了六届，也是目前备受青睐的，知名度较高的编程比赛之一。</p>
</li>
<li>
<p>百度之星，由百度公司于2005年发起并主办的年度程序设计竞赛，初赛不限制参赛选手身份要求，是影响力较大，含金量较高的编程比赛之一。</p>
</li>
</ul>
<h3 id="11-关于难度与含金量">
<a class="header-anchor" href="#11-%e5%85%b3%e4%ba%8e%e9%9a%be%e5%ba%a6%e4%b8%8e%e5%90%ab%e9%87%91%e9%87%8f"></a>
1.1 关于难度与含金量
</h3><p><img src="https://i.mji.rip/2025/10/25/a0f7dfdcc838614a0fd95124e8862f5a.png" alt="image"></p>
<blockquote>
<p>注：关于评分码蹄杯比蓝桥杯难度高：码蹄杯题目数量更大，且难度与蓝桥杯大差不差（有些更难）。另外该图表只反映外界的普遍共识，但对于我们普通人来说，无论你参加了哪个比赛都很棒！</p></blockquote>
<hr>
<h2 id="2-关于各种算法比赛的介绍">
<a class="header-anchor" href="#2-%e5%85%b3%e4%ba%8e%e5%90%84%e7%a7%8d%e7%ae%97%e6%b3%95%e6%af%94%e8%b5%9b%e7%9a%84%e4%bb%8b%e7%bb%8d"></a>
2. 关于各种算法比赛的介绍
</h2><h3 id="21-不同的赛制">
<a class="header-anchor" href="#21-%e4%b8%8d%e5%90%8c%e7%9a%84%e8%b5%9b%e5%88%b6"></a>
2.1 不同的赛制
</h3><p>根据不同的比赛规则，需要采取不同的策略来完成比赛。</p>
<h3 id="22-比赛规则之如何评分">
<a class="header-anchor" href="#22-%e6%af%94%e8%b5%9b%e8%a7%84%e5%88%99%e4%b9%8b%e5%a6%82%e4%bd%95%e8%af%84%e5%88%86"></a>
2.2 比赛规则之如何评分
</h3><p>每道算法题会有若干个检测点。检测点具体是什么东西，如何判断的呢？</p>
<p>举个例子，你编写了一个程序，现在有各种各样的用户来做测试，如果一个用户用完你的程序没有问题，体验好，那你就通过了检测。反之，如果用户做出了你没考虑到的操作，导致程序失灵出现错误，那么这个检测你就没有通过。</p>
<p>对应到程序竞赛中来说，程序每通过一个样例，没有报错，输出了符合答案预期的结果，那么这个检测点你就通过了，反之则没有通过。一般一道题会有几十个，甚至上百个这样的样例来全面，系统的检测你的程序设计是否合理（包括程序设计方法，时间，空间复杂度等多维度综合考虑）。</p>
<h3 id="23-一道题举例">
<a class="header-anchor" href="#23-%e4%b8%80%e9%81%93%e9%a2%98%e4%b8%be%e4%be%8b"></a>
2.3 一道题举例
</h3><p><strong>蓝桥杯官网[19728 拼十字]</strong></p>
<p>官网题库练习界面，有调试和提交检测按钮。调试按钮使用第一个节点的测试数据测试程序能不能得到正确结果，提交检测会检测所有测试数据，最后给出完整的结果。
<img src="https://i.postimg.cc/bJYvGGMH/20250122095816.png" alt="image"></p>
<p>怎样的答案才算是正确答案？
1.程序逻辑正确
2.满足时间复杂度和空间复杂度的要求</p>
<p><img src="https://i.postimg.cc/prpXZwPm/20250122095952.png" alt="image"></p>
<p>根据选择使用的算法不同，复杂度不同，通过率会有差别。20个检测点，使用回溯算法，通过6个，得6分。</p>
<p><img src="https://i.postimg.cc/DZCw1v3V/20250122095909.png" alt="image"></p>
<p><img src="https://i.postimg.cc/PJ9fFSq2/20250122095858.jpg" alt="image"></p>
<p><strong>==在正式比赛中，需要在指定位置上传自己的程序代码。看不到提交后的结果，不能进行调试。检测方法就是根据题目要求，自己想例子手动测试。==</strong></p>
<h3 id="24-不同规则介绍">
<a class="header-anchor" href="#24-%e4%b8%8d%e5%90%8c%e8%a7%84%e5%88%99%e4%bb%8b%e7%bb%8d"></a>
2.4 不同规则介绍
</h3><h4 id="241-icpcacm">
<a class="header-anchor" href="#241-icpcacm"></a>
2.4.1 ICPC/ACM
</h4><p>形式：3人一队、1台电脑、5小时左右，题目 8–13 道。</p>
<p>评分：按解题数排序；同解题数按罚时（最后一次通过时间之和 + 每题若干分钟的错误罚时）升序。</p>
<p>特点：强调分工协作与代码实现速度；不允许上网；常见于 ICPC、CCPC 等。</p>
        
        <hr><p>Published on 2025-10-25 at <a href='https://wittleLuna.github.io/'>wittleLuna's blog</a>, last modified on 2025-10-25</p>]]>
      </description>
      
        <category>computer algorithm</category>
      
    </item>
    
    

    <item>
      <title>[Git]Common Errors and Solutions</title>
      <link>https://wittleLuna.github.io/en/post/git%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</link>
      <pubDate>Tue, 09 Sep 2025 00:00:00 &#43;0000</pubDate>
      <author>syaz23277@gmail.com (wittleLuna)</author>
      <guid>https://wittleLuna.github.io/en/post/git%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</guid>
      <description>
        <![CDATA[<h1>[Git]Common Errors and Solutions</h1><p>Author: wittleLuna(syaz23277@gmail.com)</p>
        
          <h1 id="1拉取镜像时报错">
<a class="header-anchor" href="#1%e6%8b%89%e5%8f%96%e9%95%9c%e5%83%8f%e6%97%b6%e6%8a%a5%e9%94%99"></a>
1.拉取镜像时报错
</h1><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">hint: Updates were rejected because the tip of your current branch is behind
</span></span><span class="line"><span class="cl">hint: its remote counterpart. If you want to integrate the remote changes,
</span></span><span class="line"><span class="cl">hint: use <span class="s1">&#39;git pull&#39;</span> before pushing again.
</span></span><span class="line"><span class="cl">hint: See the <span class="s1">&#39;Note about fast-forwards&#39;</span> in <span class="s1">&#39;git push --help&#39;</span> <span class="k">for</span> details.
</span></span></code></pre></div><h2 id="出现原因">
<a class="header-anchor" href="#%e5%87%ba%e7%8e%b0%e5%8e%9f%e5%9b%a0"></a>
出现原因
</h2><p>1.别人先 push 了
团队协作时，别人往远端推送了新提交，而你本地的分支还停留在旧的版本。</p>
<p>2.本地仓库没及时同步远端
你可能有一段时间没 git pull，导致历史落后。</p>
<h2 id="解决方法">
<a class="header-anchor" href="#%e8%a7%a3%e5%86%b3%e6%96%b9%e6%b3%95"></a>
解决方法
</h2><p>不使用<code>git pull origin main</code>而是改为使用<code>git pull --rebase origin main</code>来保持直线历史。</p>
<h2 id="万金油自检顺序">
<a class="header-anchor" href="#%e4%b8%87%e9%87%91%e6%b2%b9%e8%87%aa%e6%a3%80%e9%a1%ba%e5%ba%8f"></a>
万金油自检顺序
</h2><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">git status                               <span class="c1"># 看看是否有未提交/冲突/进行中操作</span>
</span></span><span class="line"><span class="cl">git branch -vv                           <span class="c1"># 确认当前分支及其 upstream</span>
</span></span><span class="line"><span class="cl">git fetch origin                         <span class="c1"># 先拉最新引用</span>
</span></span><span class="line"><span class="cl">git pull --rebase origin &lt;your-branch&gt;   <span class="c1"># 整合远端</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 若有冲突：按提示解决 -&gt; git add -&gt; git rebase --continue</span>
</span></span><span class="line"><span class="cl">git push
</span></span></code></pre></div><p>或 git pull origin main &ndash;allow-unrelated-histories</p>
        
        <hr><p>Published on 2025-09-09 at <a href='https://wittleLuna.github.io/'>wittleLuna's blog</a>, last modified on 2025-09-09</p>]]>
      </description>
      
        <category>Git</category>
      
    </item>
    
    

    <item>
      <title>[Deep Learning]Residual Connection</title>
      <link>https://wittleLuna.github.io/en/post/%E6%AE%8B%E5%B7%AE%E8%BF%9E%E6%8E%A5/</link>
      <pubDate>Tue, 09 Sep 2025 00:00:00 &#43;0000</pubDate>
      <author>syaz23277@gmail.com (wittleLuna)</author>
      <guid>https://wittleLuna.github.io/en/post/%E6%AE%8B%E5%B7%AE%E8%BF%9E%E6%8E%A5/</guid>
      <description>
        <![CDATA[<h1>[Deep Learning]Residual Connection</h1><p>Author: wittleLuna(syaz23277@gmail.com)</p>
        
          <h2 id="-什么是残差连接">
<a class="header-anchor" href="#-%e4%bb%80%e4%b9%88%e6%98%af%e6%ae%8b%e5%b7%ae%e8%bf%9e%e6%8e%a5"></a>
📖 什么是残差连接
</h2><ul>
<li><strong>残差连接</strong>是深度学习里的一种 <strong>网络结构设计技巧</strong>，最早在 <strong>ResNet（残差网络）</strong> 中提出。</li>
<li>它的核心思想是：
👉 <strong>让输入绕过若干层神经网络，直接加到输出上。</strong></li>
</ul>
<p>公式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">y = F(x) + x
</span></span></code></pre></div><p>其中：</p>
<ul>
<li>x = 输入</li>
<li>F(x) = 若干层神经网络的变换</li>
<li>y = 输出（包含了原始输入 + 新学到的变化）</li>
</ul>
<h2 id="-为什么要用残差连接">
<a class="header-anchor" href="#-%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e7%94%a8%e6%ae%8b%e5%b7%ae%e8%bf%9e%e6%8e%a5"></a>
📌 为什么要用残差连接
</h2><ol>
<li>
<p><strong>缓解梯度消失/爆炸</strong></p>
<ul>
<li>在非常深的神经网络里，梯度可能传不下去，导致训练困难。</li>
<li>残差连接给梯度提供了一条“捷径”，更容易训练。</li>
</ul>
</li>
<li>
<p><strong>避免退化问题</strong></p>
<ul>
<li>网络越深，不一定越好，有时反而性能下降。</li>
<li>残差连接让深层网络至少能“模仿浅层网络”，避免性能变差。</li>
</ul>
</li>
<li>
<p><strong>更易学习</strong></p>
<ul>
<li>网络不需要学完整的映射 H(x)，只需学“残差” F(x) = H(x) - x，任务更简单。</li>
</ul>
</li>
</ol>
<h2 id="-直观理解">
<a class="header-anchor" href="#-%e7%9b%b4%e8%a7%82%e7%90%86%e8%a7%a3"></a>
🎯 直观理解
</h2><ul>
<li>没有残差：网络必须学会 <strong>从 0 到目标函数</strong> 的完整映射。</li>
<li>有了残差：网络只需在“已有的输入基础上，做一些修正”。</li>
</ul>
<p>👉 就像写作文：不是从零开始写，而是拿一篇草稿（输入）做修改（残差），效率更高。</p>
<h2 id="-一句话总结">
<a class="header-anchor" href="#-%e4%b8%80%e5%8f%a5%e8%af%9d%e6%80%bb%e7%bb%93"></a>
✅ 一句话总结
</h2><p><strong>残差连接就是在网络里给输入开一条“捷径”，把输入直接加到输出上，帮助训练更深的神经网络。</strong></p>
        
        <hr><p>Published on 2025-09-09 at <a href='https://wittleLuna.github.io/'>wittleLuna's blog</a>, last modified on 2025-09-09</p>]]>
      </description>
      
        <category>Deep Learning</category>
      
    </item>
    
    

    <item>
      <title>[Deep Learning]Graph Attention Network, Graph Neural Network</title>
      <link>https://wittleLuna.github.io/en/post/%E5%9B%BE%E6%B3%A8%E6%84%8F%E5%8A%9B%E7%BD%91%E7%BB%9C-%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</link>
      <pubDate>Tue, 09 Sep 2025 00:00:00 &#43;0000</pubDate>
      <author>syaz23277@gmail.com (wittleLuna)</author>
      <guid>https://wittleLuna.github.io/en/post/%E5%9B%BE%E6%B3%A8%E6%84%8F%E5%8A%9B%E7%BD%91%E7%BB%9C-%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</guid>
      <description>
        <![CDATA[<h1>[Deep Learning]Graph Attention Network, Graph Neural Network</h1><p>Author: wittleLuna(syaz23277@gmail.com)</p>
        
          <h2 id="1-信息聚合方式的区别">
<a class="header-anchor" href="#1-%e4%bf%a1%e6%81%af%e8%81%9a%e5%90%88%e6%96%b9%e5%bc%8f%e7%9a%84%e5%8c%ba%e5%88%ab"></a>
1. 信息聚合方式的区别
</h2><h3 id="-传统-gnn如-gcn">
<a class="header-anchor" href="#-%e4%bc%a0%e7%bb%9f-gnn%e5%a6%82-gcn"></a>
🔹 传统 GNN（如 GCN）
</h3><ul>
<li>采用 <strong>固定的归一化权重</strong> 来聚合邻居节点特征。</li>
<li>公式示例（GCN）：</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">h_i&#39; = \sigma\left( \sum_{j \in \mathcal{N}(i)} \frac{1}{\sqrt{d_i d_j}} W h_j \right)
</span></span></code></pre></div><p>这里权重 $\frac{1}{\sqrt{d_i d_j}}$ 仅依赖于节点度数，是预定义的，不随数据学习。
➡ 聚合方式是 <strong>静态的</strong>，缺少自适应性。</p>
<h3 id="-图注意力网络gat--gatv2">
<a class="header-anchor" href="#-%e5%9b%be%e6%b3%a8%e6%84%8f%e5%8a%9b%e7%bd%91%e7%bb%9cgat--gatv2"></a>
🔹 图注意力网络（GAT / GATv2）
</h3><ul>
<li>采用 <strong>自注意力机制</strong> 来为邻居分配权重。</li>
<li>公式：</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">h_i&#39; = \sigma\left( \sum_{j \in \mathcal{N}(i)} \alpha_{ij} W h_j \right), \quad
</span></span><span class="line"><span class="cl">\alpha_{ij} = \text{softmax}_j \big( a^T \, \text{LeakyReLU}(W[h_i \, || \, h_j]) \big)
</span></span></code></pre></div><p>其中 alpha_{ij} 是 <strong>可学习的权重</strong>，依赖于节点特征本身。
➡ 聚合方式是 <strong>动态的</strong>，模型能根据任务自动决定哪些邻居更重要。</p>
        
        <hr><p>Published on 2025-09-09 at <a href='https://wittleLuna.github.io/'>wittleLuna's blog</a>, last modified on 2025-09-09</p>]]>
      </description>
      
        <category>Deep Learning</category>
      
    </item>
    
    

    <item>
      <title>[Algorithm]Graph Attention Network v2</title>
      <link>https://wittleLuna.github.io/en/post/gatv2%E5%9B%BE%E6%B3%A8%E6%84%8F%E5%8A%9B%E7%BD%91%E7%BB%9C/</link>
      <pubDate>Tue, 09 Sep 2025 00:00:00 &#43;0000</pubDate>
      <author>syaz23277@gmail.com (wittleLuna)</author>
      <guid>https://wittleLuna.github.io/en/post/gatv2%E5%9B%BE%E6%B3%A8%E6%84%8F%E5%8A%9B%E7%BD%91%E7%BB%9C/</guid>
      <description>
        <![CDATA[<h1>[Algorithm]Graph Attention Network v2</h1><p>Author: wittleLuna(syaz23277@gmail.com)</p>
        
          <h2 id="1-背景gat-的问题">
<a class="header-anchor" href="#1-%e8%83%8c%e6%99%afgat-%e7%9a%84%e9%97%ae%e9%a2%98"></a>
1. 背景：GAT 的问题
</h2><p>GAT（Velickovic et al., ICLR 2018）通过 <strong>自注意力机制</strong> 在图结构上聚合邻居节点信息，每条边的权重由注意力函数计算：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">\alpha_{ij} = \text{softmax}_j \left( \text{LeakyReLU}(a^T [W h_i \, || \, W h_j]) \right)
</span></span></code></pre></div><p>其中 h_i 是节点特征，W 是线性变换，a 是可学习参数。
但 GAT 有一个限制：注意力权重的计算公式在 <strong>输入的线性变换</strong> 之后才进入非线性函数，因此注意力分布空间受到限制，不能区分一些对称情况。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">a^T (W h_i \, || \, W h_j) = a^T (W h_j \, || \, W h_i)
</span></span></code></pre></div><p>→ 可能导致表达能力不足。</p>
<h2 id="2-gatv2-的改进">
<a class="header-anchor" href="#2-gatv2-%e7%9a%84%e6%94%b9%e8%bf%9b"></a>
2. GATv2 的改进
</h2><p>GATv2（Brody et al., ICLR 2021）在注意力机制上进行了关键修改：
把 <strong>非线性函数移到线性变换之前</strong>，得到更强的表达能力。</p>
<p>注意力计算公式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">\alpha_{ij} = \text{softmax}_j \left( a^T \, \text{LeakyReLU}( W [h_i \, || \, h_j] ) \right)
</span></span></code></pre></div><p>区别：</p>
        
        <hr><p>Published on 2025-09-09 at <a href='https://wittleLuna.github.io/'>wittleLuna's blog</a>, last modified on 2025-09-09</p>]]>
      </description>
      
        <category>Algorithm</category>
      
    </item>
    
    

    <item>
      <title>[Algorithm]Collaborative Filtering</title>
      <link>https://wittleLuna.github.io/en/post/%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Tue, 09 Sep 2025 00:00:00 &#43;0000</pubDate>
      <author>syaz23277@gmail.com (wittleLuna)</author>
      <guid>https://wittleLuna.github.io/en/post/%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4%E7%B3%BB%E7%BB%9F/</guid>
      <description>
        <![CDATA[<h1>[Algorithm]Collaborative Filtering</h1><p>Author: wittleLuna(syaz23277@gmail.com)</p>
        
          <p><strong>协同过滤系统</strong>（Collaborative Filtering, CF）是一种推荐系统方法，它不依赖物品的内容特征，而是<strong>利用用户和物品之间的交互数据（如评分、点击、购买记录）来发现相似性并进行推荐</strong>。</p>
<h2 id="1-核心思想">
<a class="header-anchor" href="#1-%e6%a0%b8%e5%bf%83%e6%80%9d%e6%83%b3"></a>
<strong>1. 核心思想</strong>
</h2><blockquote>
<p>“志同道合的人喜欢相似的东西。”</p></blockquote>
<ul>
<li>如果用户 A 和用户 B 的兴趣很相似，那么 A 喜欢的物品，B 也可能喜欢。</li>
<li>如果物品 X 和物品 Y 被很多相同用户喜欢，那么喜欢 X 的人也可能喜欢 Y。</li>
</ul>
<h2 id="2-两大类型">
<a class="header-anchor" href="#2-%e4%b8%a4%e5%a4%a7%e7%b1%bb%e5%9e%8b"></a>
<strong>2. 两大类型</strong>
</h2><h3 id="1-基于用户的协同过滤user-based-cf">
<a class="header-anchor" href="#1-%e5%9f%ba%e4%ba%8e%e7%94%a8%e6%88%b7%e7%9a%84%e5%8d%8f%e5%90%8c%e8%bf%87%e6%bb%a4user-based-cf"></a>
(1) <strong>基于用户的协同过滤</strong>（User-Based CF）
</h3><ul>
<li>
<p>找到与目标用户兴趣相似的其他用户（邻居），推荐他们喜欢的物品。</p>
</li>
<li>
<p>例子：</p>
<ul>
<li>你喜欢电影 A、B，有另一个用户也喜欢 A、B，而且他还喜欢 C → 推荐 C 给你。</li>
</ul>
</li>
</ul>
<h3 id="2-基于物品的协同过滤item-based-cf">
<a class="header-anchor" href="#2-%e5%9f%ba%e4%ba%8e%e7%89%a9%e5%93%81%e7%9a%84%e5%8d%8f%e5%90%8c%e8%bf%87%e6%bb%a4item-based-cf"></a>
(2) <strong>基于物品的协同过滤</strong>（Item-Based CF）
</h3><ul>
<li>
<p>找到与目标物品相似的其他物品，推荐这些物品给用户。</p>
</li>
<li>
<p>例子：</p>
<ul>
<li>很多人看了电影 A 后还看了电影 B → 如果你看了 A，就推荐 B。</li>
</ul>
</li>
</ul>
<h2 id="3-优点">
<a class="header-anchor" href="#3-%e4%bc%98%e7%82%b9"></a>
<strong>3. 优点</strong>
</h2><ul>
<li>不需要物品内容信息（可以处理多媒体、文本等无法直接比较的内容）。</li>
<li>只依赖用户行为数据，容易实现。</li>
<li>可以发现意料之外的推荐（serendipity）。</li>
</ul>
<h2 id="4-缺点">
<a class="header-anchor" href="#4-%e7%bc%ba%e7%82%b9"></a>
<strong>4. 缺点</strong>
</h2><ul>
<li><strong>冷启动问题</strong>：新用户/新物品没有足够的交互数据时很难推荐。</li>
<li><strong>稀疏性问题</strong>：用户-物品矩阵很稀疏时，找到相似用户/物品的难度大。</li>
<li>无法直接利用上下文信息（时间、地点等）。</li>
</ul>
<h2 id="5-在工业界的变体">
<a class="header-anchor" href="#5-%e5%9c%a8%e5%b7%a5%e4%b8%9a%e7%95%8c%e7%9a%84%e5%8f%98%e4%bd%93"></a>
<strong>5. 在工业界的变体</strong>
</h2><ul>
<li><strong>矩阵分解</strong>（Matrix Factorization）：如 SVD、ALS，把用户和物品映射到同一个向量空间。</li>
<li><strong>深度学习 CF</strong>：用 MLP、Embedding 代替传统相似度计算（比如 YouTube 双塔模型就是一种协同过滤思想的深度实现）。</li>
</ul>
<p>📌 <strong>一句话总结</strong></p>
        
        <hr><p>Published on 2025-09-09 at <a href='https://wittleLuna.github.io/'>wittleLuna's blog</a>, last modified on 2025-09-09</p>]]>
      </description>
      
        <category>Algorithm</category>
      
    </item>
    
    

    <item>
      <title>[Git]Push the project and collaborate with multiple contributors</title>
      <link>https://wittleLuna.github.io/en/post/git%E6%8E%A8%E9%80%81%E9%A1%B9%E7%9B%AE%E5%A4%9A%E4%BA%BA%E5%8D%8F%E5%8A%A9/</link>
      <pubDate>Mon, 01 Sep 2025 00:00:00 &#43;0000</pubDate>
      <author>syaz23277@gmail.com (wittleLuna)</author>
      <guid>https://wittleLuna.github.io/en/post/git%E6%8E%A8%E9%80%81%E9%A1%B9%E7%9B%AE%E5%A4%9A%E4%BA%BA%E5%8D%8F%E5%8A%A9/</guid>
      <description>
        <![CDATA[<h1>[Git]Push the project and collaborate with multiple contributors</h1><p>Author: wittleLuna(syaz23277@gmail.com)</p>
        
          <h1 id="git如何推送项目">
<a class="header-anchor" href="#git%e5%a6%82%e4%bd%95%e6%8e%a8%e9%80%81%e9%a1%b9%e7%9b%ae"></a>
Git如何推送项目
</h1><h2 id="-从本地推送项目到-github-的完整流程">
<a class="header-anchor" href="#-%e4%bb%8e%e6%9c%ac%e5%9c%b0%e6%8e%a8%e9%80%81%e9%a1%b9%e7%9b%ae%e5%88%b0-github-%e7%9a%84%e5%ae%8c%e6%95%b4%e6%b5%81%e7%a8%8b"></a>
🚀 从本地推送项目到 GitHub 的完整流程
</h2><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># 1. 进入你的项目目录</span>
</span></span><span class="line"><span class="cl"><span class="nb">cd</span> F:/备份/项目备份GPU/algokg_platform_server（改成你的文件路径）
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 2. 初始化 Git 仓库（如果你已经 git init 过，可以跳过）</span>
</span></span><span class="line"><span class="cl">git init
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 3. 添加所有文件到暂存区</span>
</span></span><span class="line"><span class="cl">git add .
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 4. 提交到本地仓库，写提交说明</span>
</span></span><span class="line"><span class="cl">git commit -m <span class="s2">&#34;初始化项目&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 5. 确认本地分支名称（旧版本 Git 默认是 master，新版本默认是 main）</span>
</span></span><span class="line"><span class="cl">git branch
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 如果不是 main，可以把当前分支改名为 main</span>
</span></span><span class="line"><span class="cl">git branch -M main
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 6. 添加远程仓库地址（如果已经添加过，就用 set-url 修改）</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 第一次添加：</span>
</span></span><span class="line"><span class="cl"><span class="c1"># git remote add origin https://github.com/wittleLuna/AlgoKG.git</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 如果提示 remote origin already exists，说明已经绑定过，就用：</span>
</span></span><span class="line"><span class="cl">git remote set-url origin https://github.com/wittleLuna/AlgoKG.git
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 7. 拉取远程仓库的 main 分支（避免冲突，比如 GitHub 默认生成的 README.md）</span>
</span></span><span class="line"><span class="cl">git pull origin main --rebase
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 8. 推送本地 main 分支到远程，并建立跟踪关系</span>
</span></span><span class="line"><span class="cl">git push -u origin main
</span></span></code></pre></div><h2 id="-后续日常开发流程以后每次更新代码">
<a class="header-anchor" href="#-%e5%90%8e%e7%bb%ad%e6%97%a5%e5%b8%b8%e5%bc%80%e5%8f%91%e6%b5%81%e7%a8%8b%e4%bb%a5%e5%90%8e%e6%af%8f%e6%ac%a1%e6%9b%b4%e6%96%b0%e4%bb%a3%e7%a0%81"></a>
🔑 后续日常开发流程（以后每次更新代码）
</h2><p>当你修改了文件后，只需要执行以下三步：</p>
        
        <hr><p>Published on 2025-09-01 at <a href='https://wittleLuna.github.io/'>wittleLuna's blog</a>, last modified on 2025-09-01</p>]]>
      </description>
      
        <category>Git</category>
      
    </item>
    
    

    <item>
      <title>[Git]Common Commands and Usage</title>
      <link>https://wittleLuna.github.io/en/post/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</link>
      <pubDate>Mon, 01 Sep 2025 00:00:00 &#43;0000</pubDate>
      <author>syaz23277@gmail.com (wittleLuna)</author>
      <guid>https://wittleLuna.github.io/en/post/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</guid>
      <description>
        <![CDATA[<h1>[Git]Common Commands and Usage</h1><p>Author: wittleLuna(syaz23277@gmail.com)</p>
        
          <h2 id="分支">
<a class="header-anchor" href="#%e5%88%86%e6%94%af"></a>
分支
</h2><p><strong>git branch <!-- raw HTML omitted --></strong>
新建分支</p>
<p>使用分支其实就相当于在说：“我想基于这个提交以及它所有的 parent 提交进行新的工作。”</p>
<p><strong>git checkout <!-- raw HTML omitted --></strong>
切换到指定分支</p>
<blockquote>
<p>注意：在 Git 2.23 版本中，引入了一个名为 git switch 的新命令，最终会取代 git checkout，因为 checkout 作为单个命令有点超载（它承载了很多独立的功能）。</p></blockquote>
<p>更简洁的方式：如果你想创建一个新的分支同时切换到新创建的分支的话，可以通过 git checkout -b <!-- raw HTML omitted --> 来实现。</p>
<h2 id="分支与合并">
<a class="header-anchor" href="#%e5%88%86%e6%94%af%e4%b8%8e%e5%90%88%e5%b9%b6"></a>
分支与合并
</h2><p><strong>git merge &lt;你要合并的另一个分支&gt;</strong></p>
<p>在 Git 中合并两个分支时会产生一个特殊的提交记录，它有两个 parent 节点。翻译成自然语言相当于：“我要把这两个 parent 节点本身及它们所有的祖先都包含进来。</p>
<p><strong>git rebase</strong></p>
<p>取出一系列的提交记录，“复制”它们，然后在另外一个地方逐个的放下去。</p>
<h2 id="在提交树上移动">
<a class="header-anchor" href="#%e5%9c%a8%e6%8f%90%e4%ba%a4%e6%a0%91%e4%b8%8a%e7%a7%bb%e5%8a%a8"></a>
在提交树上移动
</h2><p>HEAD</p>
<p>HEAD 是一个对当前所在分支的符号引用 —— 也就是指向你正在其基础上进行工作的提交记录。</p>
<p>HEAD 总是指向当前分支上最近一次提交记录。HEAD 总是指向当前分支上最近一次提交记录。大多数修改提交树的 Git 命令都是从改变 HEAD 的指向开始的。</p>
        
        <hr><p>Published on 2025-09-01 at <a href='https://wittleLuna.github.io/'>wittleLuna's blog</a>, last modified on 2025-09-01</p>]]>
      </description>
      
        <category>Git</category>
      
    </item>
    
    

    <item>
      <title>[Mati Cup]2025 Problems — Study Notes</title>
      <link>https://wittleLuna.github.io/en/post/%E7%A0%81%E8%B9%84%E6%9D%AF/</link>
      <pubDate>Tue, 15 Jul 2025 00:00:00 &#43;0000</pubDate>
      <author>syaz23277@gmail.com (wittleLuna)</author>
      <guid>https://wittleLuna.github.io/en/post/%E7%A0%81%E8%B9%84%E6%9D%AF/</guid>
      <description>
        <![CDATA[<h1>[Mati Cup]2025 Problems — Study Notes</h1><p>Author: wittleLuna(syaz23277@gmail.com)</p>
        
          <h3 id="括号序列">
<a class="header-anchor" href="#%e6%8b%ac%e5%8f%b7%e5%ba%8f%e5%88%97"></a>
括号序列
</h3><blockquote>
<p>唐僧师徒途经一座神秘的古庙，庙前刻着一行字：“欲往决赛，需解此阵！” 小码哥自告奋勇上前查看，发现地上刻着一串由“(”和“)”括号组成的符号（长度为偶数），显然是某种法阵，但次序混乱，使得灵气无法流转。
小码哥看了一眼，笑道：“这法阵应该是要变成一套匹配的符号，才能显现出通往西天的正确道路，但怎么判断是否匹配呢？”
悟空指着庙旁的一块石碑说道：“规则在这儿！这几种情况都可以递归地定义一个括号序列是匹配的:
1.空序列是匹配的。
2.若A和B都是匹配的，则AB是匹配的。
3.若A是匹配的，则(A)是匹配的。</p>
<p>但此法阵只能交换相邻两个符号的位置，那我们最少需要多少次才能使其完全匹配呢？
小码哥摩拳擦掌：“交给我吧，我一定能算出来！”</p></blockquote>
<p>输入格式:第一行一个整数 T(T&lt; 10^6)，表示测试数据组数。对于每组测试数据:一行一个字符串，表示括号序列。数据保证，最终结果一定可以匹配。所有字符串长度之和不超过 10^6
输出格式:对于每组测试数据:输出一行一个整数，表示答案。</p>
<p>输入:</p>
<p>3
()())(
)(
()()</p>
<p>输出:</p>
<p>1
1
0</p>
<p>标签
<code>找规律</code> <code>括号匹配</code></p>
<h4 id="解题思路">
<a class="header-anchor" href="#%e8%a7%a3%e9%a2%98%e6%80%9d%e8%b7%af"></a>
解题思路
</h4><p>根据题目可以获得的信息有:</p>
<p>1.括号字符串是肯定可以匹配的，只是次序乱了
2.每次只能交换两个字符的位置</p>
<p>括号的特点:</p>
<p>匹配的括号: <code>()</code> , 不匹配的括号: <code>)(</code>, 也就是说如果不匹配，肯定是 <code>)</code> 出现在 <code>(</code> 的 前面。<strong>那么在判断需要移动几次的时候，肯定要依据 <code>(</code> 来，才能得到正确的结果，因为不匹配时, <code>(</code> 肯定是出现在不匹配字符串的后面的位置的。</strong></p>
<p>通过分别统计<code>(</code>和<code>)</code>的数量（leftbracket 和 rightbracket），和字符串当前所在的位置，来判断需要移动几次。具体操作如下:</p>
<ul>
<li>
<p>如果当前为<code>(</code>, 并且当前已经有统计的 rightbracket, 那么可以把当前的<code>(</code>向前移动 rightbracket的数量的位置，完成一个括号的匹配，匹配完成后rightbracket&ndash;, 表示当前已经匹配完成了一个<code>(</code>。 如果没有 rightbracket, lefbracket++.</p>
</li>
<li>
<p>如果当前为<code>)</code>, 并且当前已经有 leftbracket, 说明在其之前有<code>(</code>, 此时 leftbracket&ndash;即可，表明已经匹配了一个括号。如果没有, rightbracket++.</p>
</li>
</ul>
<h4 id="代码实现">
<a class="header-anchor" href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0"></a>
代码实现
</h4><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">			
</span></span></span><span class="line"><span class="cl"><span class="w">		</span><span class="n">Scanner</span><span class="w"> </span><span class="n">sc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Scanner</span><span class="p">(</span><span class="n">System</span><span class="p">.</span><span class="na">in</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">		
</span></span></span><span class="line"><span class="cl"><span class="w">		</span><span class="kt">int</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sc</span><span class="p">.</span><span class="na">nextInt</span><span class="p">();</span><span class="w"> </span><span class="c1">//t组数据</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">		
</span></span></span><span class="line"><span class="cl"><span class="w">		</span><span class="k">while</span><span class="p">(</span><span class="n">t</span><span class="w"> </span><span class="o">--</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">			
</span></span></span><span class="line"><span class="cl"><span class="w">			</span><span class="n">String</span><span class="w"> </span><span class="n">str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sc</span><span class="p">.</span><span class="na">next</span><span class="p">();</span><span class="w"> </span><span class="c1">//括号字符串</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">					
</span></span></span><span class="line"><span class="cl"><span class="w">			</span><span class="kt">int</span><span class="w"> </span><span class="n">leftBracket</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w"> </span><span class="c1">//左括号的数量</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">			
</span></span></span><span class="line"><span class="cl"><span class="w">			</span><span class="kt">int</span><span class="w"> </span><span class="n">rightBracket</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w"> </span><span class="c1">//右括号的数量</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">			
</span></span></span><span class="line"><span class="cl"><span class="w">			</span><span class="kt">int</span><span class="w"> </span><span class="n">ans</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w"> </span><span class="c1">//当前第t组的答案</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">			
</span></span></span><span class="line"><span class="cl"><span class="w">			</span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">str</span><span class="p">.</span><span class="na">length</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">				
</span></span></span><span class="line"><span class="cl"><span class="w">				</span><span class="k">if</span><span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="na">charAt</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">&#39;(&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">//当前为左括号</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">					
</span></span></span><span class="line"><span class="cl"><span class="w">					</span><span class="k">if</span><span class="p">(</span><span class="n">rightBracket</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">//右括号的数量不为0</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">						
</span></span></span><span class="line"><span class="cl"><span class="w">						</span><span class="n">ans</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">rightBracket</span><span class="p">;</span><span class="w"> </span><span class="c1">//答案 += 当前的右括号数量</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">						
</span></span></span><span class="line"><span class="cl"><span class="w">						</span><span class="n">rightBracket</span><span class="o">--</span><span class="p">;</span><span class="w"> </span><span class="c1">//减去一个右括号的数量（来表示当前左括号和右括号已经匹配）</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">						
</span></span></span><span class="line"><span class="cl"><span class="w">					</span><span class="p">}</span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">						</span><span class="n">leftBracket</span><span class="o">++</span><span class="p">;</span><span class="w"> </span><span class="c1">//右括号数量为0，说明无法匹配，记录当前的左括号</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">					</span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">				</span><span class="p">}</span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"> 	</span><span class="c1">//当前为右括号</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">					
</span></span></span><span class="line"><span class="cl"><span class="w">					</span><span class="k">if</span><span class="p">(</span><span class="n">leftBracket</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">//如果左括号数量大于0</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">					
</span></span></span><span class="line"><span class="cl"><span class="w">						</span><span class="n">leftBracket</span><span class="o">--</span><span class="p">;</span><span class="w"> </span><span class="c1">//使得左括号和右括号匹配，左括号--</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">					</span><span class="p">}</span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">						
</span></span></span><span class="line"><span class="cl"><span class="w">						</span><span class="n">rightBracket</span><span class="o">++</span><span class="p">;</span><span class="w"> </span><span class="c1">//无法匹配，增加右括号的数量</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">					</span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">					
</span></span></span><span class="line"><span class="cl"><span class="w">					
</span></span></span><span class="line"><span class="cl"><span class="w">				</span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">				
</span></span></span><span class="line"><span class="cl"><span class="w">			</span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">			</span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">ans</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">			
</span></span></span><span class="line"><span class="cl"><span class="w">		</span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h3 id="判断奇偶">
<a class="header-anchor" href="#%e5%88%a4%e6%96%ad%e5%a5%87%e5%81%b6"></a>
判断奇偶
</h3><p>唐僧师徒跋山涉水，终于来到了一座雄伟的石桥前，桥边站着一位神秘老者，拦住了他们的去路。“此桥乃通往决赛的关键之路，若想通过，需解开一道神秘考验。”老者捋着胡子说道。
小码哥自告奋勇上前询问：“请问前辈，是什么考验？”
老者点头道：“此考验涉及两组长度均为n神秘数列，分别称为‘天数列’a1~an和‘地数列’b1 ~ bn.每个数皆为正整数。”
他指了指桥上的一块石碑，上面刻着一道古老的公式：</p>
        
        <hr><p>Published on 2025-07-15 at <a href='https://wittleLuna.github.io/'>wittleLuna's blog</a>, last modified on 2025-07-15</p>]]>
      </description>
      
        <category>computer algorithm</category>
      
    </item>
    
    

    <item>
      <title>algorithm questions of lanqiao cup</title>
      <link>https://wittleLuna.github.io/en/post/%E8%93%9D%E6%A1%A5%E6%9D%AF%E9%94%99%E8%AF%AF%E6%80%BB%E7%BB%93%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</link>
      <pubDate>Sat, 14 Jun 2025 00:00:00 &#43;0000</pubDate>
      <author>syaz23277@gmail.com (wittleLuna)</author>
      <guid>https://wittleLuna.github.io/en/post/%E8%93%9D%E6%A1%A5%E6%9D%AF%E9%94%99%E8%AF%AF%E6%80%BB%E7%BB%93%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</guid>
      <description>
        <![CDATA[<h1>algorithm questions of lanqiao cup</h1><p>Author: wittleLuna(syaz23277@gmail.com)</p>
        
          <h2 id="杂题">
<a class="header-anchor" href="#%e6%9d%82%e9%a2%98"></a>
杂题
</h2><h3 id="105-油漆面积">
<a class="header-anchor" href="#105-%e6%b2%b9%e6%bc%86%e9%9d%a2%e7%a7%af"></a>
<a href="https://www.lanqiao.cn/problems/105/learning/?page=1&amp;first_category_id=1&amp;problem_id=105">105 油漆面积</a>
</h3><p><strong>错误描述</strong> ： 发生了段错误</p>
<p><strong>原因</strong>： 保持二维数组时使用了int数组，一个int占4字节。10004*10004(个int类型变量) * 4 (转换成字节) / 1000 (转换为kb/千字节) / 1024 (转换为mb) 约为390mb， 远超题目最大运行内存256mb,所以会报段字节的错误</p>
<p><strong>解决方法</strong>： 使用占用内存更小的类型，如boolean,占用1个字节</p>
<p><strong>代码实现</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">		
</span></span></span><span class="line"><span class="cl"><span class="w">	  </span><span class="n">Scanner</span><span class="w"> </span><span class="n">scan</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Scanner</span><span class="p">(</span><span class="n">System</span><span class="p">.</span><span class="na">in</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">		 
</span></span></span><span class="line"><span class="cl"><span class="w">	  </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">scan</span><span class="p">.</span><span class="na">nextInt</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">		 
</span></span></span><span class="line"><span class="cl"><span class="w">	  </span><span class="n">ArrayList</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span><span class="w"> </span><span class="n">rectangles</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ArrayList</span><span class="o">&lt;&gt;</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">		 
</span></span></span><span class="line"><span class="cl"><span class="w">	  </span><span class="kt">boolean</span><span class="o">[][]</span><span class="w"> </span><span class="n">grid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">boolean</span><span class="o">[</span><span class="n">10004</span><span class="o">][</span><span class="n">10004</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">		 
</span></span></span><span class="line"><span class="cl"><span class="w">	  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">			
</span></span></span><span class="line"><span class="cl"><span class="w">			</span><span class="kt">int</span><span class="w"> </span><span class="n">x1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">scan</span><span class="p">.</span><span class="na">nextInt</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">			</span><span class="kt">int</span><span class="w"> </span><span class="n">y1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">scan</span><span class="p">.</span><span class="na">nextInt</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">			</span><span class="kt">int</span><span class="w"> </span><span class="n">x2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">scan</span><span class="p">.</span><span class="na">nextInt</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">			</span><span class="kt">int</span><span class="w"> </span><span class="n">y2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">scan</span><span class="p">.</span><span class="na">nextInt</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">			
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">temp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">			
</span></span></span><span class="line"><span class="cl"><span class="w">			</span><span class="k">if</span><span class="p">(</span><span class="n">x1</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">x2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">				</span><span class="n">temp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x2</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">				</span><span class="n">x2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x1</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">				</span><span class="n">x1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">temp</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">			</span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">			
</span></span></span><span class="line"><span class="cl"><span class="w">			</span><span class="k">if</span><span class="p">(</span><span class="n">y1</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">y2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">				</span><span class="n">temp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y2</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">				</span><span class="n">y2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y1</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">				</span><span class="n">y1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">temp</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">			</span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">			</span><span class="n">rectangles</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="o">[]</span><span class="p">{</span><span class="n">x1</span><span class="p">,</span><span class="n">y1</span><span class="p">,</span><span class="n">x2</span><span class="p">,</span><span class="n">y2</span><span class="p">});</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">		</span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">		
</span></span></span><span class="line"><span class="cl"><span class="w">		
</span></span></span><span class="line"><span class="cl"><span class="w">		</span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">arr</span><span class="p">:</span><span class="w"> </span><span class="n">rectangles</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">			
</span></span></span><span class="line"><span class="cl"><span class="w">			</span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arr</span><span class="o">[</span><span class="n">0</span><span class="o">]</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">arr</span><span class="o">[</span><span class="n">2</span><span class="o">]</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">				</span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arr</span><span class="o">[</span><span class="n">1</span><span class="o">]</span><span class="p">;</span><span class="w"> </span><span class="n">y</span><span class="o">&lt;</span><span class="w"> </span><span class="n">arr</span><span class="o">[</span><span class="n">3</span><span class="o">]</span><span class="p">;</span><span class="w"> </span><span class="n">y</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">					</span><span class="n">grid</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">				</span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">			</span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">		
</span></span></span><span class="line"><span class="cl"><span class="w">		</span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">		
</span></span></span><span class="line"><span class="cl"><span class="w">		</span><span class="kt">int</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">		
</span></span></span><span class="line"><span class="cl"><span class="w">		</span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">grid</span><span class="p">.</span><span class="na">length</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">			</span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">grid</span><span class="o">[</span><span class="n">0</span><span class="o">]</span><span class="p">.</span><span class="na">length</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">				</span><span class="k">if</span><span class="p">(</span><span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">					</span><span class="n">result</span><span class="o">++</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">				</span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">			</span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">		</span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">		
</span></span></span><span class="line"><span class="cl"><span class="w">		</span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">result</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">		
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h3 id="3527-阶乘的和">
<a class="header-anchor" href="#3527-%e9%98%b6%e4%b9%98%e7%9a%84%e5%92%8c"></a>
<a href="https://www.lanqiao.cn/problems/3527/learning/?page=1&amp;first_category_id=1&amp;problem_id=3527">3527 阶乘的和</a>
</h3><p><strong>解题方法</strong>
从最小的数开始，尽可能多地将它的次数合并到更高一阶的数，直到无法合并为止。最终的min就是最大的m，因为此时所有比min小的阶乘已经被合并，而当前的min的阶乘次数不足以再合并到更高阶，所以m!就是最大的可能。</p>
        
        <hr><p>Published on 2025-06-14 at <a href='https://wittleLuna.github.io/'>wittleLuna's blog</a>, last modified on 2025-06-15</p>]]>
      </description>
      
        <category>algorithm question</category>
      
    </item>
    
  </channel>
</rss>
