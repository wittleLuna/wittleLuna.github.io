[
    {
      "objectID": "d62995adc6b8a6334d192da821e1f2f4-en",
      "lang": "en",
      "permalink": "https://wittleLuna.github.io/en/post/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%A5%E5%9D%91%E7%BC%96%E7%A8%8B%E6%AF%94%E8%B5%9B/",
      "title": "Getting into Competitive Programming from Zero","content": " 从零开始，入坑编程比赛 1. 什么是编程比赛？ 编程比赛，一般称为程序设计竞赛，要求选手在有限的时间内编写程序，分析和解决问题。\n国内比较出名的比赛有：\nOI（Olympiad in Informatics，信息学奥林匹克竞赛），是高中五大学科竞赛之一。\nICPC（International Collegiate Programming Contest，国际大学生程序设计竞赛），由 ICPC 基金会（ICPC Foundation）举办，是最具影响力的大学生计算机竞赛。由于以前 ACM 赞助这个竞赛，也有很多人习惯叫它 ACM 竞赛。\n蓝桥杯，由中华人民共和国工业和信息化部人才交流中心主办（据相关新闻，2026届起已与工信部脱钩），从中小学到大学高校一直备受青睐，是参加人数多，知名度较高的比赛之一。\n码蹄杯，是由全国高等学校计算机教育研究会主办、清华大学出版社承办的编程竞赛，截至2025年举办了六届，也是目前备受青睐的，知名度较高的编程比赛之一。\n百度之星，由百度公司于2005年发起并主办的年度程序设计竞赛，初赛不限制参赛选手身份要求，是影响力较大，含金量较高的编程比赛之一。\n1.1 关于难度与含金量 注：关于评分码蹄杯比蓝桥杯难度高：码蹄杯题目数量更大，且难度与蓝桥杯大差不差（有些更难）。另外该图表只反映外界的普遍共识，但对于我们普通人来说，无论你参加了哪个比赛都很棒！\n2. 关于各种算法比赛的介绍 2.1 不同的赛制 根据不同的比赛规则，需要采取不同的策略来完成比赛。\n2.2 比赛规则之如何评分 每道算法题会有若干个检测点。检测点具体是什么东西，如何判断的呢？\n举个例子，你编写了一个程序，现在有各种各样的用户来做测试，如果一个用户用完你的程序没有问题，体验好，那你就通过了检测。反之，如果用户做出了你没考虑到的操作，导致程序失灵出现错误，那么这个检测你就没有通过。\n对应到程序竞赛中来说，程序每通过一个样例，没有报错，输出了符合答案预期的结果，那么这个检测点你就通过了，反之则没有通过。一般一道题会有几十个，甚至上百个这样的样例来全面，系统的检测你的程序设计是否合理（包括程序设计方法，时间，空间复杂度等多维度综合考虑）。\n2.3 一道题举例 蓝桥杯官网[19728 拼十字]\n官网题库练习界面，有调试和提交检测按钮。调试按钮使用第一个节点的测试数据测试程序能不能得到正确结果，提交检测会检测所有测试数据，最后给出完整的结果。 怎样的答案才算是正确答案？ 1.程序逻辑正确 2.满足时间复杂度和空间复杂度的要求\n根据选择使用的算法不同，复杂度不同，通过率会有差别。20个检测点，使用回溯算法，通过6个，得6分。\n==在正式比赛中，需要在指定位置上传自己的程序代码。看不到提交后的结果，不能进行调试。检测方法就是根据题目要求，自己想例子手动测试。==\n2.4 不同规则介绍 2.4.1 ICPC/ACM 形式：3人一队、1台电脑、5小时左右，题目 8–13 道。\n评分：按解题数排序；同解题数按罚时（最后一次通过时间之和 + 每题若干分钟的错误罚时）升序。\n特点：强调分工协作与代码实现速度；不允许上网；常见于 ICPC、CCPC 等。\n2.4.2 OI/IOI 形式：个人参赛，通常 2 天，每天 3 题，每题含多个子任务。\n评分：部分分（子任务通过即得分），总分排名。\n特点：重算法设计与正确性证明，时间更充裕；不比速度，比解法完整度与稳健性；中学阶段的 NOI/IOI 属此类。\n2.4.3 “ICPC 变体”的个人赛（常见于线上平台） 代表：Codeforces、AtCoder、LeetCode 周赛等。\n形式：个人参赛，时长 1.5–2.5 小时不等，若干题（难度递增）。\n评分：\nCodeforces：解题数优先，罚时（含错误提交罚时）作为细则；部分轮次带Hack/Challenge与系统测试。\nAtCoder：固定题分，解得越早罚时越小（每次 WA 追加罚时），总分→罚时。\nLeetCode：以解题数与完成时间排序，普遍带错误罚时（平台规则偶有调整）。\n特点：节奏快、梯度清晰，适合周练与水平特征化评估（Rating）。\n蓝桥杯采用IO赛制，码蹄杯采用ACM赛制，都是个人赛\n3. 我要参加算法比赛，需要掌握哪些知识？ 入门 基础数据结构：数组，链表，字符串，栈与队列，二叉树，图论（BFS/DFS、拓扑排序、最短路（Dijkstra/Bellman-Ford）、最小生成树（Kruskal/Prim））\n基础算法套路：双指针/滑动窗口、前缀和/差分、二分， 回溯与递归，动态规划\n基础数学：整除与同余、快速幂、GCD/LCM\n进阶 高级数据结构：线段树（区间加/取 min/max/sum、懒标记）、树状数组、可持久化思想、Treap/Splay（了解）。\n图论扩展：最短路变体（SPFA 注意反例）、0-1 BFS、多源 BFS、差分约束；强连通分量（Kosaraju/Tarjan）、桥与割点、树直径、最近公共祖先（倍增/树剖）。\n流/匹配：最大流（Dinic/ISAP）、最小割、二分图匹配（匈牙利/网络流）、最小费用最大流（了解）。\n动态规划：背包（多维/多重/分组）、区间 DP、树形 DP、状态压缩 DP（bitmask）、数位 DP。\n数学进阶：组合数与预处理（阶乘/逆元/卢卡斯）、容斥、矩阵快速幂、同余方程（EXGCD）、中国剩余定理（CRT）。\n高阶 高级图论：最短路分层图、树分治/点分治、虚树、支配树（了解）、2-SAT。\n高级字符串：Z 函数、Manacher、后缀数组/后缀自动机（SAM）、AC 自动机。\n高阶数据结构：可持久化线段树/平衡树、李超线段树、分块与莫队（含带修改）。\n高数与数论加强：多项式（NTT/FFT）、拉格朗日插值、组合数变换、线性基。\n启发式与优化：启发式合并、分治优化/四边形不等式优化 DP、位运算黑科技、随机化与期望分析。\n4. 我要寻找组织，系统学习；国内外有哪些算法平台/社区？ 算法平台在程序员社区中比较普遍，也有各种各样不同类型的算法平台。同时大部分算法平台都会定期举行周赛，月赛等。\n平台/社区 推荐 Leetcode（力扣） 世界知名的学习社区，算法题量广，用户基数大，包括周赛，月赛，社区氛围好，资源内容较完善，使用友好界面简洁。\n代码随想录 包含了完整的算法学习路线，题目从易较难设置较合理，题目讲解细致。有全套的B站视频讲解，对于初学者十分友好。\n洛谷 国内知名刷题网站，题库大，定期举行比赛。\nACM/LeetCode算法竞赛路线图，最全的算法学习地图！ 使用树的形式，整理了大量算法题。\n算法竞赛模板库 by 灵茶山艾府 LeetCode竞赛前10选手做的竞赛算法目录，b站有对应的讲解。\nOI-WIKI 各类算法竞赛知识的知识整合站点，由一批热爱算法的小伙伴维护，比较偏理论介绍\nAcWing 算法题库，各类题目较全，包括周赛，月赛\nNew Online Judge 算法题库，各种类型比赛的原题比较全\n算法吧 个人算法网站，可与其他结合，对比学习使用\n作者推荐的学习顺序 第一步，你需要彻底掌握一门编程语言的基础使用，如循环，分支等，各种核心库中常用的函数都需要掌握。\n第二步，你需要学习一些基础的数据结构和算法知识，并用你掌握的编程语言进行实现。不需要学习很深入，但至少自己编程实现一遍，对算法有具体的了解\n第三步，进行算法学习，同时开始刷对应部分的算法题，了解熟悉各种不同类型的算法，并学会根据不同的题目使用何种不同的算法，在用到的时候能够实现。\n第四步，熟悉各种基础类型的算法后，继续深入更高难度的算法，同时保持做算法题并笔记记录的习惯。\n我首推代码随想录网站，作者在算法学习部分题目难度循序渐进，设置合理，不会让人感到很难，而是逐渐从易到难的理解各种算法的底层逻辑如何实现。并在B站有配套的视频课程。\n算法学习是一个需要大量时间，不断重复的过程。在过程中不懂是很正常的，这种时候只需要多看几遍，多想一点。坚持就是胜利。\n5. 作者参加算法比赛的心路历程，希望能给你些参考 我是大二从石油化学学院转入信息工程学院的，但是我从初中开始就对计算机，编程这一块比较感兴趣，当时自己学过一些C语言，简单的单片机程序等，也早就听说过蓝桥杯的大名，想着有朝一日也能得奖证明自己。\n进入本专业学习后，在老师的推荐下，我立马参加了蓝桥杯比赛，并决定使用Java来参加比赛（当时也是不理解，我看到各个不同类型的编程语言写算法题要求时间不同，就想着选个要求时间短点的。后来才了解，其实这只是由编程语言的性能决定的，你用哪种语言也不影响）。但是不得不说学习Java，也是一门很有用的语言。\n之后的日子，就是一个字：学。我总共参加了两届编程比赛（一般都是一年一届）。在学的过程中，我要平衡我的日常课程和算法学习，做好时间规划很重要。当然，这还是需要花费大量时间和心血的事请，尤其是到第二次参加前，我要同时准备雅思考试和算法比赛，同时每天还有很长时间的实训课，每天起得比鸡早(6:30)，回到宿舍堪比高中生(10点是宿舍限制回宿舍时间)。\n期间也有很多的迷茫和心理压力，自我怀疑等等。觉得自己很笨是很稀疏平常的事请，能做的也就只有反复的学，直到学懂，掌握了为止。\n说实话，我学习算法的时间不算长，从23年9月参加蓝桥杯到现在，也就两年多一点。但算法学习就是这样，需要你投入的时间成本很高，收入也不确定。不像那些水赛，你随便参加都能拿个奖。但是相应的，你确实能学到很多东西，培养自我学习能力，同时这些比赛相比大部分大学中的竞赛而言，还是较有含金量的。\n总之，我们需要坚持，这里我把自己很喜欢的一句话送给大家，希望大家都能度过一段充实有意义的大学生活,并不断向自己的目标前进！\nYou, me or nobody is gonna hit as hard as life. But it ain\u0026rsquo;t about how hard you hit. It\u0026rsquo;s about how hard you can get hit and keep moving forward. How much can you take and keep moving forward. That\u0026rsquo;s how winning is done!\n","date": "2025-10-25T00:00:00+00:00",
      "updated": "2025-10-25T17:41:41+08:00"
    }, 
    {
      "objectID": "6624464f066ab9f2d730e9c3358dbf5f-en",
      "lang": "en",
      "permalink": "https://wittleLuna.github.io/en/post/%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4%E7%B3%BB%E7%BB%9F/",
      "title": "[Algorithm]Collaborative Filtering","content": "协同过滤系统（Collaborative Filtering, CF）是一种推荐系统方法，它不依赖物品的内容特征，而是利用用户和物品之间的交互数据（如评分、点击、购买记录）来发现相似性并进行推荐。\n1. 核心思想 “志同道合的人喜欢相似的东西。”\n如果用户 A 和用户 B 的兴趣很相似，那么 A 喜欢的物品，B 也可能喜欢。 如果物品 X 和物品 Y 被很多相同用户喜欢，那么喜欢 X 的人也可能喜欢 Y。 2. 两大类型 (1) 基于用户的协同过滤（User-Based CF） 找到与目标用户兴趣相似的其他用户（邻居），推荐他们喜欢的物品。\n例子：\n你喜欢电影 A、B，有另一个用户也喜欢 A、B，而且他还喜欢 C → 推荐 C 给你。 (2) 基于物品的协同过滤（Item-Based CF） 找到与目标物品相似的其他物品，推荐这些物品给用户。\n例子：\n很多人看了电影 A 后还看了电影 B → 如果你看了 A，就推荐 B。 3. 优点 不需要物品内容信息（可以处理多媒体、文本等无法直接比较的内容）。 只依赖用户行为数据，容易实现。 可以发现意料之外的推荐（serendipity）。 4. 缺点 冷启动问题：新用户/新物品没有足够的交互数据时很难推荐。 稀疏性问题：用户-物品矩阵很稀疏时，找到相似用户/物品的难度大。 无法直接利用上下文信息（时间、地点等）。 5. 在工业界的变体 矩阵分解（Matrix Factorization）：如 SVD、ALS，把用户和物品映射到同一个向量空间。 深度学习 CF：用 MLP、Embedding 代替传统相似度计算（比如 YouTube 双塔模型就是一种协同过滤思想的深度实现）。 📌 一句话总结\n协同过滤就是用“人和人之间的兴趣相似度”或“物品和物品之间的相似度”来做推荐，它是现代深度推荐系统的理论基础之一。\n","date": "2025-09-09T00:00:00+00:00",
      "updated": "2025-09-09T14:36:58+08:00"
    }, 
    {
      "objectID": "4adae78a76cd18454aa0bae7d2843349-en",
      "lang": "en",
      "permalink": "https://wittleLuna.github.io/en/post/gatv2%E5%9B%BE%E6%B3%A8%E6%84%8F%E5%8A%9B%E7%BD%91%E7%BB%9C/",
      "title": "[Algorithm]Graph Attention Network v2","content": " 1. 背景：GAT 的问题 GAT（Velickovic et al., ICLR 2018）通过 自注意力机制 在图结构上聚合邻居节点信息，每条边的权重由注意力函数计算：\n\\alpha_{ij} = \\text{softmax}_j \\left( \\text{LeakyReLU}(a^T [W h_i \\, || \\, W h_j]) \\right) 其中 h_i 是节点特征，W 是线性变换，a 是可学习参数。 但 GAT 有一个限制：注意力权重的计算公式在 输入的线性变换 之后才进入非线性函数，因此注意力分布空间受到限制，不能区分一些对称情况。例如：\na^T (W h_i \\, || \\, W h_j) = a^T (W h_j \\, || \\, W h_i) → 可能导致表达能力不足。\n2. GATv2 的改进 GATv2（Brody et al., ICLR 2021）在注意力机制上进行了关键修改： 把 非线性函数移到线性变换之前，得到更强的表达能力。\n注意力计算公式：\n\\alpha_{ij} = \\text{softmax}_j \\left( a^T \\, \\text{LeakyReLU}( W [h_i \\, || \\, h_j] ) \\right) 区别：\nGAT：先对每个节点分别线性变换，再拼接，再做非线性。 GATv2：直接拼接原始特征，再做线性变换 + 非线性 → 更灵活。 ==这使得 GATv2 可以学习到 非对称的注意力模式，从而提升了表达能力。==\n3. 特点总结 更强表达能力：能捕捉 GAT 无法区分的模式。 兼容 GAT：如果权重矩阵退化，GATv2 可退化为 GAT。 性能提升：在多个数据集上比 GAT 表现更好，尤其在异质关系或需要方向性建模的任务上。 简单易用：代码和参数量与 GAT 几乎相同。 4. 公式回顾 节点更新公式：\nh_i\u0026#39; = \\sigma \\left( \\sum_{j \\in \\mathcal{N}(i)} \\alpha_{ij} W h_j \\right) 其中注意力：\n\\alpha_{ij} = \\frac{\\exp\\left( \\text{LeakyReLU}(a^T W [h_i \\, || \\, h_j]) \\right)}{\\sum_{k \\in \\mathcal{N}(i)} \\exp\\left( \\text{LeakyReLU}(a^T W [h_i \\, || \\, h_k]) \\right)} 和 GAT 的区别就在于 LeakyReLU 放在更前的位置。\n5. 应用场景 知识图谱问答（KGQA）：处理图谱中的实体关系，建模方向性边。 图分类 / 节点分类：尤其是图结构复杂、关系非对称的任务。 图生成 / 图谱结构学习：对边关系敏感时，GATv2 的非对称注意力很有优势。 ","date": "2025-09-09T00:00:00+00:00",
      "updated": "2025-09-09T14:36:58+08:00"
    }, 
    {
      "objectID": "dcb6cd9511b2648db127cc79997a533f-en",
      "lang": "en",
      "permalink": "https://wittleLuna.github.io/en/post/%E5%9B%BE%E6%B3%A8%E6%84%8F%E5%8A%9B%E7%BD%91%E7%BB%9C-%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/",
      "title": "[Deep Learning]Graph Attention Network, Graph Neural Network","content": " 1. 信息聚合方式的区别 🔹 传统 GNN（如 GCN） 采用 固定的归一化权重 来聚合邻居节点特征。 公式示例（GCN）： h_i\u0026#39; = \\sigma\\left( \\sum_{j \\in \\mathcal{N}(i)} \\frac{1}{\\sqrt{d_i d_j}} W h_j \\right) 这里权重 $\\frac{1}{\\sqrt{d_i d_j}}$ 仅依赖于节点度数，是预定义的，不随数据学习。 ➡ 聚合方式是 静态的，缺少自适应性。\n🔹 图注意力网络（GAT / GATv2） 采用 自注意力机制 来为邻居分配权重。 公式： h_i\u0026#39; = \\sigma\\left( \\sum_{j \\in \\mathcal{N}(i)} \\alpha_{ij} W h_j \\right), \\quad \\alpha_{ij} = \\text{softmax}_j \\big( a^T \\, \\text{LeakyReLU}(W[h_i \\, || \\, h_j]) \\big) 其中 alpha_{ij} 是 可学习的权重，依赖于节点特征本身。 ➡ 聚合方式是 动态的，模型能根据任务自动决定哪些邻居更重要。\n2. 表达能力的区别 传统 GNN（GCN, GraphSAGE 等）：对所有邻居的贡献大体一致，只能学习“平均化”或“加权和”的表示。 GAT 系列：允许不同邻居有不同的重要性，可以突出关键邻居、弱化噪声邻居，表达能力更强。 3. 可解释性的区别 传统 GNN：聚合权重由图结构决定，难以解释“为什么这个邻居重要”。 GAT 系列：注意力权重 alpha_{ij} 可以直接看作“节点 i 对邻居 j 的依赖程度”，可解释性更好。 4. 适用场景的区别 传统 GNN：适合结构相对规则的图（如社交网络、引文网络），邻居的贡献差别不大。 图注意力网络：适合异质图、知识图谱、推荐系统等场景——因为这些图的边类型复杂、邻居的重要性差异大。 5. 小总结 方面 传统 GNN (如 GCN) 图注意力网络 (GAT / GATv2) 聚合方式 固定权重（度数归一化） 动态权重（自注意力学习） 表达能力 相对有限 更灵活、更强 可解释性 较弱 较强（注意力可视化） 适用场景 同质图、规则图 异质图、复杂关系图 ","date": "2025-09-09T00:00:00+00:00",
      "updated": "2025-09-09T14:36:58+08:00"
    }, 
    {
      "objectID": "afacf803fd1274679fd65187032f3388-en",
      "lang": "en",
      "permalink": "https://wittleLuna.github.io/en/post/%E6%AE%8B%E5%B7%AE%E8%BF%9E%E6%8E%A5/",
      "title": "[Deep Learning]Residual Connection","content": " 📖 什么是残差连接 残差连接是深度学习里的一种 网络结构设计技巧，最早在 ResNet（残差网络） 中提出。 它的核心思想是： 👉 让输入绕过若干层神经网络，直接加到输出上。 公式：\ny = F(x) + x 其中：\nx = 输入 F(x) = 若干层神经网络的变换 y = 输出（包含了原始输入 + 新学到的变化） 📌 为什么要用残差连接 缓解梯度消失/爆炸\n在非常深的神经网络里，梯度可能传不下去，导致训练困难。 残差连接给梯度提供了一条“捷径”，更容易训练。 避免退化问题\n网络越深，不一定越好，有时反而性能下降。 残差连接让深层网络至少能“模仿浅层网络”，避免性能变差。 更易学习\n网络不需要学完整的映射 H(x)，只需学“残差” F(x) = H(x) - x，任务更简单。 🎯 直观理解 没有残差：网络必须学会 从 0 到目标函数 的完整映射。 有了残差：网络只需在“已有的输入基础上，做一些修正”。 👉 就像写作文：不是从零开始写，而是拿一篇草稿（输入）做修改（残差），效率更高。\n✅ 一句话总结 残差连接就是在网络里给输入开一条“捷径”，把输入直接加到输出上，帮助训练更深的神经网络。\n","date": "2025-09-09T00:00:00+00:00",
      "updated": "2025-09-09T14:36:58+08:00"
    }, 
    {
      "objectID": "ba0227469ab790e7b9503b88e81b7e61-en",
      "lang": "en",
      "permalink": "https://wittleLuna.github.io/en/post/git%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/",
      "title": "[Git]Common Errors and Solutions","content": " 1.拉取镜像时报错 hint: Updates were rejected because the tip of your current branch is behind hint: its remote counterpart. If you want to integrate the remote changes, hint: use \u0026#39;git pull\u0026#39; before pushing again. hint: See the \u0026#39;Note about fast-forwards\u0026#39; in \u0026#39;git push --help\u0026#39; for details. 出现原因 1.别人先 push 了 团队协作时，别人往远端推送了新提交，而你本地的分支还停留在旧的版本。\n2.本地仓库没及时同步远端 你可能有一段时间没 git pull，导致历史落后。\n解决方法 不使用git pull origin main而是改为使用git pull --rebase origin main来保持直线历史。\n万金油自检顺序 git status # 看看是否有未提交/冲突/进行中操作 git branch -vv # 确认当前分支及其 upstream git fetch origin # 先拉最新引用 git pull --rebase origin \u0026lt;your-branch\u0026gt; # 整合远端 # 若有冲突：按提示解决 -\u0026gt; git add -\u0026gt; git rebase --continue git push 或 git pull origin main \u0026ndash;allow-unrelated-histories\n","date": "2025-09-09T00:00:00+00:00",
      "updated": "2025-09-09T14:36:58+08:00"
    }, 
    {
      "objectID": "0d27cbeee9b8171434b6853dd40e88ad-en",
      "lang": "en",
      "permalink": "https://wittleLuna.github.io/en/post/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/",
      "title": "[Git]Common Commands and Usage","content": " 分支 git branch 新建分支\n使用分支其实就相当于在说：“我想基于这个提交以及它所有的 parent 提交进行新的工作。”\ngit checkout 切换到指定分支\n注意：在 Git 2.23 版本中，引入了一个名为 git switch 的新命令，最终会取代 git checkout，因为 checkout 作为单个命令有点超载（它承载了很多独立的功能）。\n更简洁的方式：如果你想创建一个新的分支同时切换到新创建的分支的话，可以通过 git checkout -b 来实现。\n分支与合并 git merge \u0026lt;你要合并的另一个分支\u0026gt;\n在 Git 中合并两个分支时会产生一个特殊的提交记录，它有两个 parent 节点。翻译成自然语言相当于：“我要把这两个 parent 节点本身及它们所有的祖先都包含进来。\ngit rebase\n取出一系列的提交记录，“复制”它们，然后在另外一个地方逐个的放下去。\n在提交树上移动 HEAD\nHEAD 是一个对当前所在分支的符号引用 —— 也就是指向你正在其基础上进行工作的提交记录。\nHEAD 总是指向当前分支上最近一次提交记录。HEAD 总是指向当前分支上最近一次提交记录。大多数修改提交树的 Git 命令都是从改变 HEAD 的指向开始的。\n分离的 HEAD\n分离的 HEAD 就是让其指向了某个具体的提交记录而不是分支名。\n相对引用 git log 来查查看提交记录的哈希值。\n根据哈希值进行移动 git branch -f \u0026lt;分支\u0026gt; \u0026lt;指定提交记录的哈希值位置\u0026gt;\n“ ^ ” 操作符\n相对引用非常给力，这里我介绍两个简单的用法：\n使用 ^ 向上移动 1 个提交记录 使用 ~ 向上移动多个提交记录，如 ~3 git checkout \u0026lt;分支\u0026gt;^ “~”操作符\n如果你想在提交树中向上移动很多步的话，敲那么多 ^ 貌似也挺烦人的，Git 当然也考虑到了这一点，于是又引入了操作符 ~。\n该操作符后面可以跟一个数字（可选，不跟数字时与 ^ 相同，向上移动一次），指定向上移动多少次。\n强制修改分支位置 可以直接使用 -f 选项让分支指向另一个提交。例如:\ngit branch -f main HEAD~3\n上面的命令会将 main 分支强制指向 HEAD 的第 3 级 parent 提交。\n撤销变更 主要有两种方法用来撤销变更 —— 一是 git reset，还有就是 git revert\ngit reset 通过把分支记录回退几个提交记录来实现撤销改动。你可以将这想象成“改写历史”。 git reset 向上移动分支，原来指向的提交记录就跟从来没有提交过一样。\n为了撤销更改并分享给别人，我们需要使用 git revert，新建一个和之前版本一样的新分支\n远程仓库 git clone 命令的作用是在本地创建一个远程仓库的拷贝\n远程分支 由于远程分支的特性导致其拥有一些特殊属性。 远程分支反映了远程仓库(在你上次和它通信时)的状态。 远程分支有一个特别的属性，在你切换到远程分支时，自动进入分离 HEAD 状态。Git 这么做是出于不能直接在这些分支上进行操作的原因, 你必须在别的地方完成你的工作, （更新了远程分支之后）再用远程分享你的工作成果。\nGit Fetch 从远程仓库获取数据\nGit 远程仓库相当的操作实际可以归纳为两点：向远程仓库传输数据以及从远程仓库获取数据。既然我们能与远程仓库同步，那么就可以分享任何能被 Git 管理的更新\ngit fetch 做了些什么 git fetch 完成了仅有的但是很重要的两步:\n1.从远程仓库下载本地仓库中缺失的提交记录 2.更新远程分支指针(如 origin main)\ngit fetch 实际上将本地仓库中的远程分支更新成了远程仓库相应分支最新的状态。\ngit fetch 不会做的事 git fetch 并不会改变你本地仓库的状态。它不会更新你的 main 分支，也不会修改你磁盘上的文件。\nGit Pull git pull 就是 git fetch 和 git merge 的缩写！\nGit Push git push 负责将你的变更上传到指定的远程仓库，并在远程仓库上合并你的新提交记录。一旦 git push 完成, 你的朋友们就可以从这个远程仓库下载你分享的成果了！\n","date": "2025-09-01T00:00:00+00:00",
      "updated": "2025-09-01T14:36:58+08:00"
    }, 
    {
      "objectID": "f58b9b257d7dc72fab83409b02481270-en",
      "lang": "en",
      "permalink": "https://wittleLuna.github.io/en/post/git%E6%8E%A8%E9%80%81%E9%A1%B9%E7%9B%AE%E5%A4%9A%E4%BA%BA%E5%8D%8F%E5%8A%A9/",
      "title": "[Git]Push the project and collaborate with multiple contributors","content": " Git如何推送项目 🚀 从本地推送项目到 GitHub 的完整流程 # 1. 进入你的项目目录 cd F:/备份/项目备份GPU/algokg_platform_server（改成你的文件路径） # 2. 初始化 Git 仓库（如果你已经 git init 过，可以跳过） git init # 3. 添加所有文件到暂存区 git add . # 4. 提交到本地仓库，写提交说明 git commit -m \u0026#34;初始化项目\u0026#34; # 5. 确认本地分支名称（旧版本 Git 默认是 master，新版本默认是 main） git branch # 如果不是 main，可以把当前分支改名为 main git branch -M main # 6. 添加远程仓库地址（如果已经添加过，就用 set-url 修改） # 第一次添加： # git remote add origin https://github.com/wittleLuna/AlgoKG.git # 如果提示 remote origin already exists，说明已经绑定过，就用： git remote set-url origin https://github.com/wittleLuna/AlgoKG.git # 7. 拉取远程仓库的 main 分支（避免冲突，比如 GitHub 默认生成的 README.md） git pull origin main --rebase # 8. 推送本地 main 分支到远程，并建立跟踪关系 git push -u origin main 🔑 后续日常开发流程（以后每次更新代码） 当你修改了文件后，只需要执行以下三步：\n# 查看状态，确认改了哪些文件 git status # 添加改动 git add . # 提交改动 git commit -m \u0026#34;修改了XXX功能\u0026#34; # 推送到远程仓库 git push Git如何多人协作 🟢 情况 1：你们是协作开发（推荐） 步骤 你给别人添加权限\n打开 GitHub 仓库页面 → Settings → Collaborators → 添加对方的 GitHub 用户名 / 邮箱 → 发送邀请。 对方接受后，就能对仓库有 push 权限。 别人克隆仓库\ngit clone https://github.com/wittleLuna/AlgoKG.git cd AlgoKG 别人日常操作\n# 修改代码后 git add . git commit -m \u0026#34;修改了XXX\u0026#34; git push origin main ✅ 就能把代码直接推送到你的仓库。\n🟡 情况 2：你不想直接给权限（更安全） 这种情况适合 开源项目 或者 只想让别人贡献代码但不想给写权限。\n流程是 Fork + Pull Request：\n别人在 GitHub 上点击你的仓库 → Fork → 复制一份到自己的账户。 在自己账户的仓库里改代码、commit、push。 改好后发起 Pull Request (PR) 给你。 你在仓库里审核 → 如果同意，就合并进主仓库。 拉取远程仓库文件 git pull origin main git pull origin main --allow-unrelated-histories git remote set-url origin https://github.com/wittleLuna/AlgoKG.git\n","date": "2025-09-01T00:00:00+00:00",
      "updated": "2025-09-01T14:36:58+08:00"
    }, 
    {
      "objectID": "878015405502d481a0095ddf8183b1ca-en",
      "lang": "en",
      "permalink": "https://wittleLuna.github.io/en/post/%E7%A0%81%E8%B9%84%E6%9D%AF/",
      "title": "[Mati Cup]2025 Problems — Study Notes","content": " 括号序列 唐僧师徒途经一座神秘的古庙，庙前刻着一行字：“欲往决赛，需解此阵！” 小码哥自告奋勇上前查看，发现地上刻着一串由“(”和“)”括号组成的符号（长度为偶数），显然是某种法阵，但次序混乱，使得灵气无法流转。 小码哥看了一眼，笑道：“这法阵应该是要变成一套匹配的符号，才能显现出通往西天的正确道路，但怎么判断是否匹配呢？” 悟空指着庙旁的一块石碑说道：“规则在这儿！这几种情况都可以递归地定义一个括号序列是匹配的: 1.空序列是匹配的。 2.若A和B都是匹配的，则AB是匹配的。 3.若A是匹配的，则(A)是匹配的。\n但此法阵只能交换相邻两个符号的位置，那我们最少需要多少次才能使其完全匹配呢？ 小码哥摩拳擦掌：“交给我吧，我一定能算出来！”\n输入格式:第一行一个整数 T(T\u0026amp;lt; 10^6)，表示测试数据组数。对于每组测试数据:一行一个字符串，表示括号序列。数据保证，最终结果一定可以匹配。所有字符串长度之和不超过 10^6 输出格式:对于每组测试数据:输出一行一个整数，表示答案。\n输入:\n3 ()())( )( ()()\n输出:\n1 1 0\n标签 找规律 括号匹配\n解题思路 根据题目可以获得的信息有:\n1.括号字符串是肯定可以匹配的，只是次序乱了 2.每次只能交换两个字符的位置\n括号的特点:\n匹配的括号: () , 不匹配的括号: )(, 也就是说如果不匹配，肯定是 ) 出现在 ( 的 前面。那么在判断需要移动几次的时候，肯定要依据 ( 来，才能得到正确的结果，因为不匹配时, ( 肯定是出现在不匹配字符串的后面的位置的。\n通过分别统计(和)的数量（leftbracket 和 rightbracket），和字符串当前所在的位置，来判断需要移动几次。具体操作如下:\n如果当前为(, 并且当前已经有统计的 rightbracket, 那么可以把当前的( …","date": "2025-07-15T00:00:00+00:00",
      "updated": "2025-07-15T14:36:58+08:00"
    }, 
    {
      "objectID": "5840f0be3985306ab2f1b5cca4f9f6c9-en",
      "lang": "en",
      "permalink": "https://wittleLuna.github.io/en/post/%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/",
      "title": "[Basic knowledge]Data Structure and Algorithms","content": " 数据结构和算法 经典算法题 字符串匹配问题： 暴力匹配 KMP算法 八皇后：回溯算法 汉诺塔：分治算法 马踏棋盘：图的深度优化遍历算法(DFS)+贪心算法\n线性结构和非线性结构 数据结构包括线性结构和非线性结构\n线性结构 最常用的线性结构\n特点：数据之间存在==一对一==的线性关系\n存储结构：\n顺序存储结构（数组）：顺序存储的线性表称为顺序表，==顺序表中的存储元素是连续的（内存分配的地址是连续的）==\n链式存储结构（链表）：链式存储的线性表称为链表，==存储元素不一定连续==\n常见的线性结构：数组，队列，链表，栈\n非线性结构 不是一对一的关系\n常见的非线性结构：二维数组，多维数组，广义表，树结构，图结构\n稀疏数组和队列 稀疏数组(sparseArray) 如：用二维数组记录棋盘数据，有很多0，记录了很多没有意义的数据 基本介绍： 当一个数组中大部分元素是0，或者为同一个值的数组时，可以使用稀疏数组来保存数组。\n稀疏数组的处理方法：\n1.记录数组一共有几行几列，有多少个不同的值\n2.把具有不同值的元素的行列及值记录在一个小规模数组中，从而缩小程序的规模\n稀疏数组转二维数组：\n1.遍历原始二维数组，得到有效数据的个数sum\n2.根据sum创建sum创建sparsearr int[sum + 1][3]\n3.将二维数组的有效数据存到一维数组\n二维数组转稀疏数组：\n1.先读取稀疏数组的第一行，根据第一行的数据，创建原始二维数组\n2.再读取稀疏数组后几行的数据，并赋给原始的二维数组\n代码实现 package sparsearray; public class SparsearrDemo1 { public static void main(String[] args) { int[][] arr = new int[11][11]; arr[1][2] = 1; …","date": "2025-06-14T00:00:00+00:00",
      "updated": "2025-06-15T14:39:44+08:00"
    }, 
    {
      "objectID": "3ec19241c503f5bfa4d6d6cd12368936-en",
      "lang": "en",
      "permalink": "https://wittleLuna.github.io/en/post/huggingface-%E4%B9%8B-%E4%BD%BF%E7%94%A8space-%E5%88%9B%E5%BB%BA%E8%81%8A%E5%A4%A9%E7%A8%8B%E5%BA%8F/",
      "title": "[Huggingface] How to build your space","content": " 简单介绍 Hugging Face, Inc. is a French-American company based in New York City that develops computation tools for building applications using machine learning. It is most notable for its transformers library built for natural language processing applications and its platform that allows users to share machine learning models and datasets and showcase their work.\n简单来说就是一个社区，它提供了服务器的功能，用户可以把自己建立的应用，模型等通过它的服务能够在公网进行访问和使用\n前提准备 huggingface, github账号 第一步 建立新的space 在这里选择new space, 可以看到huggingface还支持建立模型，数据集等，这些目前用不到\n这一步需要填写下列内容 你的空间名称\n对空间的描述\n许可，这里可默认不写\n选择空间的SDK, 这一步很关键，决定了你的空间是何种类型的;可以看到我们可以使用Gradio构建web应用，用HTML构建静态内容，或者使用Docker拉取镜像。\n这里Huggingface提供了很丰富的不同版本的内容，可按照个人喜好自由选择 公开/私有： 决定你的空间是否别人能够访问\n第二部，配置 Space 以我这里选择Gradio为例（不同类型流程也是一样的），你现在需要做的事情有：\n克隆space到自己的Github仓库\n创建/修改克隆到仓库中的文件内容，以符合你的需要\n如图，这是我的space项目，我简单修改了其中的app.py内容，使其能够通过我的Key访问大模型，实现简单的AI问答功能 我这里通过 Github 的 codespace功能， 很方便就能实现对文件的修改和上传功能，而且其布局也和Vscode完全一致 当你完成后，需要把这些文件push到space中，完成对space内容中的更新：\n具体推送需要用到的指令如下： git add . git remote add origin-hf https://huggingface.co/spaces/wittleLuna/Test git commit -am \u0026#34;app.py requirements.txt(例子，这里写你的文件名)\u0026#34; git push origin-hf main --force 具体解释： git add . 意思： 把当前目录下的所有改动文件（包括新建的）添加到 Git 暂存区（staging area）。\n用途： 你必须先 add，才能 commit。这一步表示“我准备提交这些文件”。\ngit remote add origin-hf https://huggingface.co/spaces/wittleLuna/Test 意思： 为当前 Git 仓库添加一个远程地址，名字叫 origin-hf，对应的是 Hugging Face Spaces 上你的 Space 项目的 Git 地址。\n用途： 以后你可以使用这个名字 origin-hf 来 push 或 pull 到这个 Hugging Face Space。\n🧠 类似于给 Git 起了个别名：origin-hf 指向 Hugging Face Space。\ngit commit -am \u0026quot;app.py requirements.txt(例子，这里写你的文件名)\u0026quot; 意思： 把你暂存的更改保存为一次“提交”，并附上提交信息（备注说明）：\n-a：自动将修改过的文件加入提交（不包含新文件） -m：后面跟的是提交信息，比如你改了哪些文件 ⚠️ 注意：新建文件（没 git add 过）不会被 -a 自动提交，仍需手动 git add . 先添加。\ngit push origin-hf main --force 意思： 将本地的 main 分支强制推送到 Hugging Face 的远程 origin-hf 仓库（覆盖远程内容）。\n--force：如果远程仓库已有内容（比如模板代码），这会强制覆盖。 ⚠️ 风险：--force 会覆盖远程仓库的历史，建议只有你明确知道要“重新上传整个 Space 项目”时才用它。\n第三步 Space运行上线 当你成功上传了文件后，在你的space 页面的上方的no application file将进入运行状态，类似与服务器，你可以从旁边的log查看日志，以便排查错误。\n现在只需要耐心等待space构建完毕，你自己的space项目便上线可用了！只要你设置为了Public,所有人都可以通过你的Space地址来使用。\n这里是我构建的简单AI问答space,你也可以考虑实现更复杂功能的space。 ","date": "2025-06-14T00:00:00+00:00",
      "updated": "2025-06-15T14:38:34+08:00"
    }, 
    {
      "objectID": "33f933bd343a607362e0b249de0590ec-en",
      "lang": "en",
      "permalink": "https://wittleLuna.github.io/en/post/openwebui-%E4%B9%8B-%E4%BD%BF%E7%94%A8pipeline-%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9E%8B%E8%B0%83%E7%94%A8/",
      "title": "[Openwebui] How to use pipeline","content": " 方法一： 用 Docker 容器运行 Pipelines docker run -d -p 9099:9099 \\ --add-host=host.docker.internal:host-gateway \\ -v /home/yourname/my-pipelines:/app/pipelines \\ --name pipelines \\ --restart always \\ ghcr.io/open-webui/pipelines:main 这种方法直接使用官方预构建的 Docker 镜像，自动加载 /app/pipelines 路径下的 pipeline 文件；将你写好的 pipeline 挂载进去即可使用\n官方镜像下载慢，但是华为云又版本过低？没事，这里我已经帮你找到了南京大学的镜像，速度快，版本新，十分甚至九分的好用\nghcr.nju.edu.cn/open-webui/pipelines:main 方法二： 本地部署pipelines 第一步：克隆官方pipeline仓库 git clone https://github.com/open-webui/pipelines.git cd pipelines python3.11 -m venv venv source venv/bin/activate pip install -r requirements.txt 注意的点 关于 clone github 仓库 如果你拥有自己的服务器，可以在云端进行。而且vscode支持远程连接时git 仓库，很方便（可能需要科学上网），也可以选择先克隆到本地，再把写好的文件上传到云端服务器\n关于 requirement.txt 需要rustc和cargo的支持，需要先下载rust。直接安装依赖可能报错 第二步：创建 rag_pipeline.py 文件 📁 在 pipelines/ 目录下新建：\n# pipelines/rag_pipeline.py from openwebui.pipelines import PipelineStep from rag_report_generator import ReportGenerator class RAGPipeline(PipelineStep): def __init__(self): # 保留你原来的逻辑 self.generator = ReportGenerator() def run(self, data: dict) -\u0026gt; dict: query = data.get(\u0026#34;user_input\u0026#34;, \u0026#34;\u0026#34;) # OpenWebUI 会传 user_input result = self.generator.generate_report(query) return { \u0026#34;response\u0026#34;: result # 返回给前端 } 代码片段，仅供参考。\n这里的自定义pipeline可参考 (https://github.com/open-webui/pipelines/blob/main/examples/pipelines)中官方的pipeline写法\n第三步：启动 Pipelines 服务 sh ./start.sh 成功后会默认监听：\nhttp://localhost:9099/v1/chat/completions 你可以在浏览器尝试访问 http://localhost:9099/docs 查看接口文档是否加载。\n这种方法会启动本地 Python 脚本，运行一个 FastAPI 服务，监听 9099 端口,会自动加载你本地 pipelines/ 文件夹中的所有 pipeline 文件（.py）\n适合场景：\n开发者在调试自定义 pipeline；\n不想用 Docker 或暂时测试环境未准备好；\n更灵活，便于打 log 和调试。\n额外注意事项\n请仔细查看openwebui的官方文档，是否正确安装了所需的依赖和所需的python版本，其中提到3.11是唯一支持的python版本！\n在 OpenWebUI 设置中绑定 Pipelines 打开 OpenWebUI Web 页面\n进入 设置 → 外部连接\n添加一个模型：\nURL填写：http://\u0026lt;你的服务器地址\u0026gt;:9099/ 密钥： 0p3n-w3bu! 你会看到有一个图标显示在该连接上，说明你的pipeline连接成功了\n上传本地/从GitHub上下载pipeline\n现在你可以从模型列表中看到pipeline, 可以直接与其对话\n","date": "2025-06-14T00:00:00+00:00",
      "updated": "2025-06-15T14:38:47+08:00"
    }, 
    {
      "objectID": "9857ac6b72a87029be956f036d9ee5d4-en",
      "lang": "en",
      "permalink": "https://wittleLuna.github.io/en/post/%E8%93%9D%E6%A1%A5%E6%9D%AF%E9%94%99%E8%AF%AF%E6%80%BB%E7%BB%93%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/",
      "title": "algorithm questions of lanqiao cup","content": " 杂题 105 油漆面积 错误描述 ： 发生了段错误\n原因： 保持二维数组时使用了int数组，一个int占4字节。10004*10004(个int类型变量) * 4 (转换成字节) / 1000 (转换为kb/千字节) / 1024 (转换为mb) 约为390mb， 远超题目最大运行内存256mb,所以会报段字节的错误\n解决方法： 使用占用内存更小的类型，如boolean,占用1个字节\n代码实现\npublic static void main(String[] args) { Scanner scan = new Scanner(System.in); int n = scan.nextInt(); ArrayList\u0026amp;lt;int[]\u0026amp;gt; rectangles = new ArrayList\u0026amp;lt;\u0026amp;gt;(); boolean[][] grid = new boolean[10004][10004]; for(int i = 0 ; i \u0026amp;lt; n ; i++) { int x1 = scan.nextInt(); int y1 = scan.nextInt(); int x2 = scan.nextInt(); int y2 = scan.nextInt(); int temp = 0; if(x1 \u0026amp;gt; x2) { temp = x2; x2 = x1; x1 = temp; } if(y1 \u0026amp;gt; y2) { temp = y2; y2 = y1; y1 = temp; } rectangles.add(new int[]{x1,y1,x2,y2}); } for(int[] arr: rectangles) { for(int x = arr[0]; x \u0026amp;lt; arr[2]; x++) { for(int y = arr[1]; y\u0026amp;lt; …","date": "2025-06-14T00:00:00+00:00",
      "updated": "2025-06-15T14:40:07+08:00"
    }, 
    {
      "objectID": "72a54093b13861d65bc821ddb8913c16-en",
      "lang": "en",
      "permalink": "https://wittleLuna.github.io/en/post/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/",
      "title": "dynamic programming","content": " 动规五部曲 确定dp数组和下标的含义 写出递推公式 确定dp数组如何初始化 确定遍历顺序（方向） 打印，举例推导验证dp数组是否正确 背包问题 01背包 可使用二维背包，一维滚动背包 二维背包 基本了解 基本递推公式 : dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]]+value[i])\ndp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少\n遍历顺序一般是先物品，再背包。也可以先背包，再物品\n第一列初始化为0，第一行为第一个物品能否装入的价值\ndp的方向是由左上方决定的，遍历顺序从前往后/从后往前都可以\n一维背包/滚动背包 基本递推公式 : dp[j] = max(dp[j],dp[j - weight[i]] + value[i]) 需要先遍历物品，再遍历背包，遍历背包时要倒序遍历 初始化为0 dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j] 为什么背包容量循环需要倒序： dp[j - weight[i]] + value[i] : 说明是从左边的值来寻找当前合适的值\n如果倒序，此时j从大到小，从左边：左边初始化都为0，所以不会使用到已经用过的物品\n如果顺序，此时j从小到大，从左边：假如已经填了第一个物品，那么第二次，查找左边，就会继续把第一个物品的值加上\n题型类型 1.纯01背包，计算背包装满的最大价值\n2.能否填满背包（一般背包容量也可以是指定数字，数组里的数作为元素，能否达到指定数字）\n不同点：返回值是和需要的容量作比较后的布尔值 3.尽量填满背包\n4.填满背包的方法数量\n不同点 ：\n1.递推公式不同: 总填充方法 = 不要该物品的填充方法+空出该物品容量，要该物品的填充方法，以及分支条件，如果装不下该物品，采用之前的填充方法数\ndp[j] += dp[j - weight[i]]\n2.初始化方式不同：第一行为第一个物品填满该容量的方法，第一列为1（空容量，不放物品有一种方法）\n5.填二维背包（有两种重量）\n不同点：\n1.递推公式不同，因为是二维背包，所以需要减去两个维度的重量:dp[i][j] = max(dp[i][j], dp[i-weight[x]][j-weight[y]]) 2.遍历背包容量时，从后向前遍历\n多重背包 有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品都有无限个（也就是可以放入背包多次），求解将哪些物品装入背包里物品价值总和最大。\n和01背包不同的是：此时内层for循环的顺序为从小到大，无需倒序 背包容量和物品的先后顺序决定是求组合数还是求排列数 先物品 后背包 : 组合数 先背包 后物品 ：排列数 完全背包 有N种物品和一个容量为V 的背包。第i种物品最多有Mi件可用，每件耗费的空间是Ci ，价值是Wi 。求解将哪些物品装入背包可使这些物品的耗费的空间 总和不超过背包容量，且价值总和最大。\n把每件物品看作一件，就是01背包问题 打家劫舍 子序列问题 常见题目类型 单序列的判断： 【最长递增子序列】 示例 1： 输入：nums = [10,9,2,5,3,7,101,18] 输出：4 解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。\n不要求是子数组，但要求子序列中的数严格递增\ndp的定义 ： i之前，包括i,以nums[i]为结尾的最长递增子序列的长度\n递推公式 :\n使用两层for循环，外层作为当前循环到的元素nums[i],内层作为其之前的数nums[j]\n位置i的最长升序子序列等于j从0到i-1各个位置的最长升序子序列 + 1 的最大值\n判断是否当前nums[i] \u0026gt; nums[j]\ndp[i] = max(dp[i] + 1 , dp[i])\n初始化：\n全都初始化为1，单个子序列 结果 ： 根据dp数组的定义，结果并不是在dp[length-1]中，而是要在循环里寻找以某个nums[i]为结尾的最大值\n【最长连续递增子序列】 示例 1： 输入：nums = [1,3,5,4,7] 输出：3 解释：最长连续递增序列是 [1,3,5], 长度为3。 尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。\n与上一题相比，多了连续,说明要按照数组中的数字顺序严格递增\n只需要判断当前nums[i]的前一个数nums[i-1],无需再遍历之前所有数\ndp的定义和上一题相同\n递推公式：\n只需要判断if(nums[i] \u0026gt; nums[i - 1]),无需第二层循环 【最大子数组和】 给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n子数组 是数组中的一个连续部分。\n示例 1：\n输入：nums = [-2,1,-3,4,-1,2,1,-5,4] 输出：6 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。\n和 【最长递增子序列】 类似， 不需要连续，但是求最大的和，而不是最长有多少个\ndp定义也差不多相同 ：以下标i(nums[i])为结尾的最大连续子序列和为dp[i]\n递推公式\n不需要判断 dp[i] = max(dp[i - 1] + nums[i] , dp[i]) 有可能当前的比之前的大，所以要取最大值 同理，最后的结果不再最后一个dp[length-1]中\n双序列的判断 【最长重复子数组】 给两个整数数组 nums1 和 nums2 ，返回 两个数组中 公共的 、长度最长的子数组的长度 。\n示例 1： 输入：nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7] 输出：3 解释：长度最长的公共子数组是 [3,2,1] 。\n==dp数组的定义 ： 以i-1为结尾的nums1[i-1] 和 以 j-1 为结尾的nums2[j-1] 的最长重复子数组为dp[i][j]== ==为什么要定义为i-1,j-1而不是i,j : 省去了初始化时的麻烦，直接初始化为0就可以了== 如果定义 dp[i][j]为 以下标i为结尾的A，和以下标j 为结尾的B，那么 第一行和第一列毕竟要进行初始化，如果nums1[i] 与 nums2[0] 相同的话，对应的 dp[i][0]就要初始为1， 因为此时最长重复子数组为1。 nums2[j] 与 nums1[0]相同的话，同理。\n需要判断的是两数组当前以i-1,j-1为结尾时的子数组是否相同，相同说明此时是重复数组 递推公式 ： for循环 ： 两次，从1开始，结束条件为\u0026lt;=length, 是根据dp数组的定义决定的\n判断条件 : nums1[i-1] == nums[j-1]\ndp[i][j] = dp[i-1][j-1] + 1\n注意最后的结果不在dp[length][length] 而是在循环中某处得到的最大值 【最长公共子序列】 给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。\n一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。\n例如，\u0026ldquo;ace\u0026rdquo; 是 \u0026ldquo;abcde\u0026rdquo; 的子序列，但 \u0026ldquo;aec\u0026rdquo; 不是 \u0026ldquo;abcde\u0026rdquo; 的子序列。 两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。\n示例 1：\n输入：text1 = \u0026ldquo;abcde\u0026rdquo;, text2 = \u0026ldquo;ace\u0026rdquo; 输出：3\n解释：最长公共子序列是 \u0026ldquo;ace\u0026rdquo; ，它的长度为 3 。\n和 【最长递增子序列 】 类似， 不过是两个数组。\n不要求是公共子序列（不严格递增）\ndp数组的定义:长度为[0, i - 1]的字符串text1与长度为[0, j - 1]的字符串text2的最长公共子序列为dp[i][j]\n递推公式 ：\n需要在上一题的基础上加上进一步判断如果当时两个数不相同的条件 如果相同， 和上一道题相同 dp[i][j] = dp[i-1][j-1] + 1 如果不相同，在两个数组之前拿到的最大值中取最大的一个 dp[i][j] = max(dp[i-1][j], dp[i][j-1]) 注意此时是从[0 - i]的最大值，所以本题的最大值就在dp[length][length]里\n【不相交的线】 在两条独立的水平线上按给定的顺序写下 nums1 和 nums2 中的整数。\n现在，可以绘制一些连接两个数字 nums1[i] 和 nums2[j] 的直线，这些直线需要同时满足：\nnums1[i] == nums2[j] 且绘制的直线不与任何其他连线（非水平线）相交。 请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。\n以这种方法绘制线条，并返回可以绘制的最大连线数。\n示例 1：\n输入：nums1 = [1,4,2], nums2 = [1,2,4] 输出：2 解释：可以画出两条不交叉的线，如上图所示。 但无法画出第三条不相交的直线，因为从 nums1[1]=4 到 nums2[2]=4 的直线将与从 nums1[2]=2 到 nums2[1]=2 的直线相交。\n其实就是求最长公共子序列 【判断子序列】 给定字符串 s 和 t ，判断 s 是否为 t 的子序列。\n字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，\u0026ldquo;ace\u0026quot;是\u0026quot;abcde\u0026quot;的一个子序列，而\u0026quot;aec\u0026quot;不是）。\n示例 1：\n输入：s = \u0026ldquo;abc\u0026rdquo;, t = \u0026ldquo;ahbgdc\u0026rdquo; 输出：true\n和 【最长公共子序列】 类似，不过本题只需要删除t，s不动 dp数组的定义和 【最长公共子序列】 相同 递推公式： 此时的else分支条件发生变化: 原是 ： dp[i][j] = max(dp[i-1][j], dp[i][j-1]) 此时 ： dp[i][j] = dp[i-1][j] (i作为代表t的数组时) 解释 ： 如果此时两字符串的最后一个字符不相同，那么就需要减去t当前的字符，把dp[t-1]中的内容作为最大值。而s不能变。 结果 ： 判断最后结果是否等于s字符串的长度 【不同的子序列】 给你两个字符串 s 和 t ，统计并返回在 s 的 子序列 中 t 出现的个数，结果需要对 109 + 7 取模。\n示例 1：\n输入：s = \u0026ldquo;rabbbit\u0026rdquo;, t = \u0026ldquo;rabbit\u0026rdquo; 输出：3 解释： 如下所示, 有 3 种可以从 s 中得到 \u0026ldquo;rabbit\u0026rdquo; 的方案。 rabbbit rabbbit rabbbit\n和 【判断子序列】 , 【最长公共子序列】 类似 , 不过改成了求出现的个数，而不是最长有多长\ndp[i][j]：以i-1为结尾的s子序列中出现以j-1为结尾的t的个数为dp[i][j]。\n递推公式\nif(s[i-1] == t[j-1]): dp[i][j] = dp[i-1][j-1]+dp[i-1][j] else: dp[i][j] = dp[i-1][j] 不同点 : 不是判断是否为子序列(不求最大值)，也不是求最长公共子序列(不求严格顺序最大值), 而是求有几个，所以需要当相等时，用当前dp+之前dp,不等时，相当于最大值为之前的dp。\n初始化: 根据递推公式可得，此时要对根据dp的定义数组进行初始化(dp[i][0],dp[0][j])。\ndp[i][0]: 以i-1为结尾的s可以随便删除元素，出现空字符串的个数。:当i=1，应该有一个空字符串，所以应都初始化为1 dp[0][j]: 空字符串s可以随便删除元素，出现以j-1为结尾的字符串t的个数,0 dp[0][0]：应该是1，空字符串s，可以删除0个元素，变成空字符串t。 【两个字符串的删除操作】 给定两个单词 word1 和 word2 ，返回使得 word1 和 word2 相同所需的最小步数。\n每步 可以删除任意一个字符串中的一个字符。\n示例 1：\n输入: word1 = \u0026ldquo;sea\u0026rdquo;, word2 = \u0026ldquo;eat\u0026rdquo; 输出: 2 解释: 第一步将 \u0026ldquo;sea\u0026rdquo; 变为 \u0026ldquo;ea\u0026rdquo; ，第二步将 \u0026ldquo;eat \u0026ldquo;变为 \u0026ldquo;ea\u0026rdquo;\ndp数组的定义： 以i-1为结尾的word1 和 j-1为结尾的word2 ， 想要达到相等，需要删除元素的最小次数\n递推公式 ： 分为此时 i-1 == j-1 , i-1 != j-1 两种。如果相等，说明不需要删除，保持上一次的操作次数，如果不相等，就有 ： 删除word1中的字符，删除word2中的字符，同时删除两个中的字符三种情况，在这三种情况中取最小值。\nif(sword1[i-1] == word2[j-1]): dp[i][j] = dp[i-1][j-1] else: dp[i][j] = math.max(dp[i-1][j] + 1, math.max(dp[i][j-1] + 1, dp[i-1][j-1] + 2)) 【编辑距离】 给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数。\n你可以对一个单词进行如下三种操作：\n插入一个字符\n删除一个字符\n替换一个字符\n示例 1：\n输入：word1 = \u0026ldquo;horse\u0026rdquo;, word2 = \u0026ldquo;ros\u0026rdquo;\n输出：3\ndp数组的定义 ： 和上一道一样 需要注意的是，如何通过dp数组实现这三种操作？ 对于插入/删除 ： 其实删除一个word1中的字符和word2中插入一个字符操作一样 例如 word1 = \u0026ldquo;ad\u0026rdquo; ，word2 = \u0026ldquo;a\u0026rdquo;，word1删除元素\u0026rsquo;d\u0026rsquo; 和 word2添加一个元素\u0026rsquo;d\u0026rsquo;，变成word1=\u0026ldquo;a\u0026rdquo;, word2=\u0026ldquo;ad\u0026rdquo;， 最终的操作数是一样 对于替换操作 ： 相当于在之前的dp[i-1][j-1]的基础上+1 递推公式: if(word1.charAt(i-1) == word2.charAt(j-1)) { dp[i][j] = dp[i-1][j-1]; //如果相同，不操作 }else { //如果不相同，在word1，word2，两个字符都删除的操作中选择操作数最小的 dp[i][j] = Math.min(dp[i-1][j] + 1, Math.min(dp[i][j-1] + 1, dp[i-1][j-1]+2)); } 【回文子串】 给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。\n具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。\n示例 1：\n输入：\u0026ldquo;abc\u0026rdquo; 输出：3 解释：三个回文子串: \u0026ldquo;a\u0026rdquo;, \u0026ldquo;b\u0026rdquo;, \u0026ldquo;c\u0026rdquo;\ndp数组的定义 ： 和之前求什么定义什么不同，此时要从回文串的性质来推导 ： 左边字符记作i,右边字符记作j,两字符相同时，此时有三种情况： 1.i,j指向同一个字符 ： 此时是回文子串 2.i,j相隔一个字符: 此时也是回文子串 3.i,j之间的距离 \u0026gt; 1 : 那么就要看 i-1, j-1对应区间的子串是否为回文字符，如果是，那么此时也是回文子串 dp[i][j]：表示区间范围[i,j] （注意是左闭右闭）的子串是否是回文子串，如果是dp[i][j]为true，否则为false。 if(s.charAt(i) == s.charAt(j)) { if(j - i \u0026lt;= 1) { dp[i][j] = true; result++; }else { if(dp[i+1][j-1] == true) { dp[i][j] = true; result++; } } } 遍历顺序 ： 根据递推公式确定，因为当前dp[i][j]是由dp[i+1][j-1]推导得出的，也就是由左下方推导出的，所以遍历顺序应当从下到上，从左到右进行遍历\n初始化：默认都为false，避免出错\n【最长回文子序列】 给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。\n子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。\n示例 1：\n输入：s = \u0026ldquo;bbbab\u0026rdquo; 输出：4 解释：一个可能的最长回文子序列为 \u0026ldquo;bbbb\u0026rdquo; 。\n和上一题【回文子串】类似，不过由求回文子串变成了求回文子序列，两者最大的区别是子串要求连续，子序列不要求连续\ndp[i][j]： i~j之间范围内最长的回文子序列\n递推公式：\n此时，如果i,j相同，那么就相当于在之前的回文子序列范围上+2个字符作为最长回文子序列\n如果i,j不相同，那么就从只取i,或者只取j的情况下选出最大值作为此时的最长子序列\n//如果i 和 j相等，从原来的最长子序列上加两个字符 if(s.charAt(i) == s.charAt(j)) { dp[i][j] = dp[i+1][j-1] + 2; }else { //如果不相等，就从取i，取j，两个字符串里取最大值 dp[i][j] = Math.max(dp[i][j-1], dp[i+1][j]); } 遍历顺序 ： 根据递推公式，可以知道还是从左下，左，下，三个方向递推当前结果，所以要从下往上，从左往右进行初始化\n数组初始化：如果此时i == j,说明此时是回文子序列，长度为1。\n//初始化当i = j时的情况为1（一个字符） for(int i = 0 ; i \u0026lt; s.length() ; i++) { dp[i][i] = 1; } 返回的结果 ： 根据dp的定义，应当返回:dp[0][s.length()-1],范围最大时的回文子串。 ","date": "2025-06-14T00:00:00+00:00",
      "updated": "2025-06-15T14:38:58+08:00"
    }, 
    {
      "objectID": "08d916ce800c13a660e205c615063679-en",
      "lang": "en",
      "permalink": "https://wittleLuna.github.io/en/post/dfsbfs%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/",
      "title": "theoretical basis of DFS/BFS","content": " 深度优先搜索理论基础 两者大概的区别： dfs是朝一个方向去搜，不到黄河不回头，直到遇到绝境了，搜不下去了，再换方向（换方向的过程就涉及到了回溯）。\nbfs是先把本节点所连接的所有节点遍历一遍，走到下一个节点的时候，再把连接节点的所有节点遍历一遍，搜索方向更像是广度，四面八方的搜索过程。\ndfs搜索过程 如图一，是一个无向图，我们要搜索从节点1到节点6的所有路径。 那么dfs搜索的第一条路径是这样的： （假设第一次延默认方向，就找到了节点6），图二 此时我们找到了节点6，（遇到黄河了，是不是应该回头了），那么应该再去搜索其他方向了。 如图三： 路径2撤销了，改变了方向，走路径3（红色线）， 接着也找到终点6。 那么撤销路径2，改为路径3，在dfs中其实就是回溯的过程（这一点很重要，很多录友不理解dfs代码中回溯是用来干什么的）\n又找到了一条从节点1到节点6的路径，又到黄河了，此时再回头，下图图四中，路径4撤销（回溯的过程），改为路径5。 又找到了一条从节点1到节点6的路径，又到黄河了，此时再回头，下图图五，路径6撤销（回溯的过程），改为路径7，路径8 和 路径7，路径9， 结果发现死路一条，都走到了自己走过的节点。 那么节点2所连接路径和节点3所链接的路径 都走过了，撤销路径只能向上回退，去选择撤销当初节点4的选择，也就是撤销路径5，改为路径10 。 如图图六： 上图演示中，其实我并没有把 所有的 从节点1 到节点6的dfs（深度优先搜索）的过程都画出来，那样太冗余了，但 已经把dfs 关键的地方都涉及到了，关键就两点：\n搜索方向，是认准一个方向搜，直到碰壁之后再换方向 换方向是撤销原路径，改为节点链接的下一个路径，回溯的过程。 代码框架 二叉树的递归法其实就是dfs，而二叉树的迭代法，就是bfs（广度优先搜索）\n所以dfs，bfs其实是基础搜索算法，也广泛应用与其他数据结构与算法中。\n回溯法代码框架:\nvoid backtracking(参数) { if (终止条件) { 存放结果; return; } for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) { 处理节点; backtracking(路径，选择列表); // 递归 回溯，撤销处理结果 } } 回溯算法，其实就是dfs的过程\ndfs算法框架:\nvoid dfs(参数) { if (终止条件) { 存放结果; return; } for (选择：本节点所连接的其他节点) { 处理节点; dfs(图，选择的节点); // 递归 回溯，撤销处理结果 } } 深搜三部曲 1.确认递归函数，参数\n一般情况，深搜需要 二维数组数组结构保存所有路径，需要一维数组保存单一路径，这种保存结果的数组，我们可以定义一个全局变量，避免让我们的函数参数过多。\n如:\nArrayList\u0026lt;ArrayList\u0026lt;int\u0026gt;\u0026gt; result; // 保存符合条件的所有路径 ArrayList\u0026lt;int\u0026gt; path; // 起点到终点的路径 void dfs (图，目前搜索的节点) 2.确认终止条件\nif (终止条件) { 存放结果; return; } 终止添加不仅是结束本层递归，同时也是我们收获结果的时候。\n3.处理目前搜索节点出发的路径\nfor (选择：本节点所连接的其他节点) { 处理节点; dfs(图，选择的节点); // 递归 回溯，撤销处理结果 } 广度优先搜索理论基础 广搜的应用场景 广搜的搜索方式就适合于解决两个点之间的最短路径问题。\n因为广搜是从起点出发，以起始点为中心一圈一圈进行搜索，一旦遇到终点，记录之前走过的节点就是一条最短路。\n当然，也有一些问题是广搜 和 深搜都可以解决的，例如岛屿问题，这类问题的特征就是不涉及具体的遍历方式，只要能把相邻且相同属性的节点标记上就行。\n广搜的过程 我们用一个方格地图，假如每次搜索的方向为 上下左右（不包含斜上方），那么给出一个start起始位置，那么BFS就是从四个方向走出第一步。 如果加上一个end终止位置，那么使用BFS的搜索过程如图所示： 我们从图中可以看出，从start起点开始，是一圈一圈，向外搜索，方格编号1为第一步遍历的节点，方格编号2为第二步遍历的节点，第四步的时候我们找到终止点end。\n正是因为BFS一圈一圈的遍历方式，所以一旦遇到终止点，那么一定是一条最短路径。\n而且地图还可以有障碍，如图所示: 从图中可以看出，如果添加了障碍，我们是第六步才能走到end终点。\n只要BFS只要搜到终点一定是一条最短路径\n代码框架 需要一个容器，能保存我们要遍历过的元素就可以，那么用队列，还是用栈，甚至用数组，都是可以的。\n用队列的话，就是保证每一圈都是一个方向去转，例如统一顺时针或者逆时针。\n因为队列是先进先出，加入元素和弹出元素的顺序是没有改变的。\n如果用栈的话，就是第一圈顺时针遍历，第二圈逆时针遍历，第三圈有顺时针遍历。\n因为栈是先进后出，加入元素和弹出元素的顺序改变了。\n那么广搜需要注意 转圈搜索的顺序吗？ 不需要！\n// 表示四个方向：右、下、左、上 private static final int[][] dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; // grid 是地图，visited 用来标记访问过的节点 public static void bfs(char[][] grid, boolean[][] visited, int x, int y) { Queue\u0026lt;int[]\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); // 定义队列 queue.offer(new int[]{x, y}); // 起始节点加入队列 visited[x][y] = true; // 只要加入队列，立刻标记为访问过的节点 while (!queue.isEmpty()) { // 开始遍历队列里的元素 int[] cur = queue.poll(); // 从队列取出元素 int curx = cur[0]; int cury = cur[1]; // 当前节点坐标 // 开始想当前节点的四个方向（右、下、左、上）去遍历 for (int i = 0; i \u0026lt; 4; i++) { int nextx = curx + dir[i][0]; int nexty = cury + dir[i][1]; // 获取周边四个方向的坐标 // 坐标越界了，直接跳过 if (nextx \u0026lt; 0 || nextx \u0026gt;= grid.length || nexty \u0026lt; 0 || nexty \u0026gt;= grid[0].length) { continue; } // 如果节点没被访问过 if (!visited[nextx][nexty]) { queue.offer(new int[]{nextx, nexty}); // 队列添加该节点为下一轮要遍历的节点 visited[nextx][nexty] = true; // 只要加入队列立刻标记，避免重复访问 } } } } ","date": "2025-06-14T00:00:00+00:00",
      "updated": "2025-06-15T14:37:49+08:00"
    }, 
    {
      "objectID": "c7cd35aad8111e2ecee01efdd394514b-en",
      "lang": "en",
      "permalink": "https://wittleLuna.github.io/en/post/%E5%9B%BE%E8%AE%BA%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/",
      "title": "theoretical basis of Graph Theory","content": " 图论 图论理论基础 图的基本概念 二维坐标中，两点可以连成线，多个点连成的线就构成了图。\n当然图也可以就一个节点，甚至没有节点（空图）\n图的种类 整体上分为有向图和无向图\n有向图：图中边是有方向的： 无向图：图中边没有方向: 加权有向图，就是图中边是有权值的: 加权无向图也是同理\n度 无向图:有几条边连接该节点，该节点就有几度 例如，该无向图中，节点4的度为5，节点6的度为3。 有向图:每个节点有出度和入度 出度：从该节点出发的边的个数 入度:指向该节点的边的个数\n例如，该有向图中，节点3的入度为2，出度为1，节点1的入度为0，出度为2。 连通性 在图中表示节点的连通情况，称之为连通性\n连通图 在无向图中，任何两个节点都是可以到达的，我们称之为连通图 如果有节点不能到达其他节点，则为非连通图 强连通图 在有向图中，任何两个节点是可以相互到达的，我们称之为 强连通图。、\n注意：强连通图是在有向图中任何两个节点是可以相互到达\n这个图不是强连通图，因为1能到5的位置，但是5不能到1的位置。\n这个图是强连通图\n连通分量 在无向图中的极大连通子图称之为该图的一个连通分量。 该无向图中节点1、节点2、节点5构成的子图就是 该无向图中的一个连通分量，该子图所有节点都是相互可达到的。\n同理，节点3、节点4、节点6构成的子图 也是该无向图中的一个连通分量。\n那么无向图中节点3 、节点4构成的子图 是该无向图的联通分量吗？\n不是！\n因为必须是极大联通子图才能是连通分量，所以 必须是节点3、节点4、节点6构成的子图才是连通分量。\n在图论中，连通分量是一个很重要的概念，例如岛屿问题（后面章节会有专门讲解）其实就是求连通分量。\n强连通分量 在有向图中极大强连通子图称之为该图的强连通分量。 节点1、节点2、节点3、节点4、节点5 构成的子图是强连通分量，因为这是强连通图，也是极大图。\n节点6、节点7、节点8构成的子图 不是强连通分量，因为这不是强连通图，节点8 不能达到节点6。\n节点1、节点2、节点5 构成的子图 也不是 强连通分量，因为这不是极大图。\n图的构造 一般使用邻接表、邻接矩阵 或者用类来表示。\n主要是 朴素存储、邻接表和邻接矩阵。\n邻接矩阵 邻接矩阵 使用 二维数组来表示图结构。 邻接矩阵是从节点的角度来表示图，有多少节点就申请多大的二维数组。\n例如： grid[2][5] = 6，表示 节点 2 连接 节点5 为有向图，节点2 指向 节点5，边的权值为6。\n如果想表示无向图，即：grid[2][5] = 6，grid[5][2] = 6，表示节点2 与 节点5 相互连通，权值为6。\n在一个 n （节点数）为8 的图中，就需要申请 8 * 8 这么大的空间。\n图中有一条双向边，即：grid[2][5] = 6，grid[5][2] = 6\n这种表达方式（邻接矩阵） 在 边少，节点多的情况下，会导致申请过大的二维数组，造成空间浪费。\n而且在寻找节点连接情况的时候，需要遍历整个矩阵，即 n * n 的时间复杂度，同样造成时间浪费。\n邻接矩阵的优点：\n表达方式简单，易于理解 检查任意两个顶点间是否存在边的操作非常快 适合稠密图，在边数接近顶点数平方的图中，邻接矩阵是一种空间效率较高的表示方法。 缺点：\n遇到稀疏图，会导致申请过大的二维数组造成空间浪费 且遍历 边 的时候需要遍历整个n * n矩阵，造成时间浪费 邻接表 邻接表 使用 数组 + 链表的方式来表示。 邻接表是从边的数量来表示图，有多少边 才会申请对应大小的链表。\n这里表达的图是：\n节点1 指向 节点3 和 节点5 节点2 指向 节点4、节点3、节点5 节点3 指向 节点4 节点4指向节点1 有多少边 邻接表才会申请多少个对应的链表节点。 从图中可以直观看出 使用 数组 + 链表 来表达 边的连接情况 。\n邻接表的优点：\n对于稀疏图的存储，只需要存储边，空间利用率高 遍历节点连接情况相对容易\n缺点：\n检查任意两个节点间是否存在边，效率相对低，需要 O(V)时间，V表示某节点连接其他节点的数量。 实现相对复杂，不易理解 以上大家可能理解比较模糊，没关系，因为大家还没做过图论的题目，对于图的表达没有概念。\n这里我先不给出具体的实现代码，大家先有个初步印象，在后面算法题实战中，我还会讲到具体代码实现，等带大家做算法题，写了代码之后，自然就理解了。\n图的遍历方式 图的遍历方式基本是两大类：\n深度优先搜索（dfs） 广度优先搜索（bfs）\n二叉树的递归遍历，是dfs 在二叉树上的遍历方式。\n二叉树的层序遍历，是bfs 在二叉树上的遍历方式。\ndfs 和 bfs 一种搜索算法，可以在不同的数据结构上进行搜索，在二叉树章节里是在二叉树这样的数据结构上搜索。\n而在图论章节，则是在图（邻接表或邻接矩阵）上进行搜索。\n","date": "2025-06-14T00:00:00+00:00",
      "updated": "2025-06-15T14:39:22+08:00"
    }, 
    {
      "objectID": "af8d9e6ebb52f38a177f234d18a71818-en",
      "lang": "en",
      "permalink": "https://wittleLuna.github.io/en/post/dijkstra%E7%AE%97%E6%B3%95/",
      "title": "Djikstra","content": "dijkstra 三部曲：\n第一步，选源点到哪个节点近且该节点未被访问过 第二步，该最近节点被标记访问过 第三步，更新非访问节点到源点的距离（即更新minDist数组）\n==解决单源最短路径问题，适用于有向图和无向图，但边权值不能为负==\n参加科学大会 解题思路 使用dijkstra模板实现\n代码实现\npublic static void main(String[] args){ Scanner sc = new Scanner(System.in); int pointsNum = sc.nextInt(); int edgesNum = sc.nextInt(); int[][] map = new int[pointsNum + 1][pointsNum + 1];\tboolean[] isTree = new boolean[pointsNum+1]; int[] minDis = new int[pointsNum + 1]; Arrays.fill(minDis, Integer.MAX_VALUE); minDis[1] = 0; for(int i = 0 ; i \u0026lt; edgesNum; i++) { int p1 = sc.nextInt(); int p2 = sc.nextInt(); int v = sc.nextInt(); map[p1][p2] = v; } for(int i = 1; i \u0026lt;= pointsNum; i ++) { int cur = 1; int min = Integer.MAX_VALUE; //第一步，选距离源点最近且未访问过的节点 for(int j = 1; j \u0026lt;= pointsNum; j++) { if(!isTree[j] \u0026amp;\u0026amp; minDis[j] \u0026lt; min) { min = minDis[j]; cur = j; } } //第二步，标记该节点为已经访问 isTree[cur] = true; //第三步，更新minDis， 非访问节点到源点的距离 for(int j = 1; j \u0026lt;= pointsNum; j++) { if(!isTree[j] \u0026amp;\u0026amp; map[cur][j] != 0 \u0026amp;\u0026amp; minDis[cur] + map[cur][j] \u0026lt; minDis[j]) { minDis[j] = minDis[cur] + map[cur][j]; //minDis[cur] + map[cur][j] 当前节点到源点的距离 + 当前节点到该非访问节点的距离 } } } if(minDis[pointsNum] == Integer.MAX_VALUE) { System.out.println(-1); }else { System.out.println(minDis[pointsNum]); } } 堆优化版本 import java.util.*; class Edge { int to; // 邻接顶点 int val; // 边的权重 Edge(int to, int val) { this.to = to; this.val = val; } } class MyComparison implements Comparator\u0026lt;Pair\u0026lt;Integer, Integer\u0026gt;\u0026gt; { @Override public int compare(Pair\u0026lt;Integer, Integer\u0026gt; lhs, Pair\u0026lt;Integer, Integer\u0026gt; rhs) { return Integer.compare(lhs.second, rhs.second); } } class Pair\u0026lt;U, V\u0026gt; { public final U first; public final V second; public Pair(U first, V second) { this.first = first; this.second = second; } } public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); int m = scanner.nextInt(); List\u0026lt;List\u0026lt;Edge\u0026gt;\u0026gt; grid = new ArrayList\u0026lt;\u0026gt;(n + 1); for (int i = 0; i \u0026lt;= n; i++) { grid.add(new ArrayList\u0026lt;\u0026gt;()); } for (int i = 0; i \u0026lt; m; i++) { int p1 = scanner.nextInt(); int p2 = scanner.nextInt(); int val = scanner.nextInt(); grid.get(p1).add(new Edge(p2, val)); } int start = 1; // 起点 int end = n; // 终点 // 存储从源点到每个节点的最短距离 int[] minDist = new int[n + 1]; Arrays.fill(minDist, Integer.MAX_VALUE); // 记录顶点是否被访问过 boolean[] visited = new boolean[n + 1]; // 优先队列中存放 Pair\u0026lt;节点，源点到该节点的权值\u0026gt; PriorityQueue\u0026lt;Pair\u0026lt;Integer, Integer\u0026gt;\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;(new MyComparison()); // 初始化队列，源点到源点的距离为0，所以初始为0 pq.add(new Pair\u0026lt;\u0026gt;(start, 0)); minDist[start] = 0; // 起始点到自身的距离为0 while (!pq.isEmpty()) { // 1. 第一步，选源点到哪个节点近且该节点未被访问过（通过优先级队列来实现） // \u0026lt;节点， 源点到该节点的距离\u0026gt; Pair\u0026lt;Integer, Integer\u0026gt; cur = pq.poll(); if (visited[cur.first]) continue; // 2. 第二步，该最近节点被标记访问过 visited[cur.first] = true; // 3. 第三步，更新非访问节点到源点的距离（即更新minDist数组） for (Edge edge : grid.get(cur.first)) { // 遍历 cur指向的节点，cur指向的节点为 edge // cur指向的节点edge.to，这条边的权值为 edge.val if (!visited[edge.to] \u0026amp;\u0026amp; minDist[cur.first] + edge.val \u0026lt; minDist[edge.to]) { // 更新minDist minDist[edge.to] = minDist[cur.first] + edge.val; pq.add(new Pair\u0026lt;\u0026gt;(edge.to, minDist[edge.to])); } } } if (minDist[end] == Integer.MAX_VALUE) { System.out.println(-1); // 不能到达终点 } else { System.out.println(minDist[end]); // 到达终点最短路径 } } } ","date": "2025-06-12T00:00:00+00:00",
      "updated": "2025-06-15T14:38:05+08:00"
    }, 
    {
      "objectID": "f7c17377324c8c2ad02f6bbdad9713d9-en",
      "lang": "en",
      "permalink": "https://wittleLuna.github.io/en/post/%E5%9B%BE%E8%AE%BA%E9%A2%98/",
      "title": "Graph questions","content": " 图的存储 邻接矩阵 Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); //n是节点数 int m = scanner.nextInt(); //m是边数 // 节点编号从1到n，所以申请 n+1 这么大的数组 int[][] graph = new int[n + 1][n + 1]; for (int i = 0; i \u0026amp;lt; m; i++) { int s = scanner.nextInt(); int t = scanner.nextInt(); // 使用邻接矩阵表示无向图，1 表示 s 与 t 是相连的 graph[s][t] = 1; } 邻接表 Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); //n是节点数 int m = scanner.nextInt(); //m是边数 // 节点编号从1到n，所以申请 n+1 这么大的数组 List\u0026amp;lt;LinkedList\u0026amp;lt;Integer\u0026amp;gt;\u0026amp;gt; graph = new ArrayList\u0026amp;lt;\u0026amp;gt;(n + 1); for (int i = 0; i \u0026amp;lt;= n; i++) { graph.add(new LinkedList\u0026amp;lt;\u0026amp;gt;()); } while (m-- \u0026amp;gt; 0) { int s = scanner.nextInt(); int t = scanner.nextInt(); // 使用邻接表表示 s -\u0026amp;gt; t 是相连的 graph.get(s).add(t); } 所有可达路径 题目描述 给定一个有 n 个节点的有向无环图，节点编号从 1 到 n。请编写一个函数，找出并返回所有从 …","date": "2025-06-12T00:00:00+00:00",
      "updated": "2025-06-15T14:39:32+08:00"
    }, 
    {
      "objectID": "553990afda82dc3f3fca468252c0adb1-en",
      "lang": "en",
      "permalink": "https://wittleLuna.github.io/en/post/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95prim-kruskal/",
      "title": "Minimum Spanning Tree","content": "最小生成树是所有节点的最小连通子图，即：以最小的成本（边的权值）将图中所有节点链接到一起。\nprim算法 图中有n个节点，那么一定可以用n-1条边将所有节点连接到一起。\n==只适用于加权无向图==\n那么如何选择这n-1条边就是最小生成树算法的任务所在。\n在这个图中，如何选取n-1条边使得图中所有节点连接到一起，并且边的权值和最小呢？\n（图中为n为7，即7个节点，那么只需要n-1即6条边就可以讲所有顶点连接到一起）\nprim算法是从节点的角度采用贪心的策略每次寻找距离最小生成树最近的节点并加入到最小生成树中。\nprim算法核心就是三步，我称为prim三部曲，大家一定要熟悉这三步，代码相对会好些很多：\n第一步，选距离生成树最近节点 第二步，最近节点加入生成树 第三步，更新非生成树节点到生成树的距离（即更新minDist数组） minDist数组的含义：记录每一个节点距离最小生成树的最近距离。\n最小生成树prim算法\n寻宝 在世界的某个区域，有一些分散的神秘岛屿，每个岛屿上都有一种珍稀的资源或者宝藏。国王打算在这些岛屿上建公路，方便运输。\n不同岛屿之间，路途距离不同，国王希望你可以规划建公路的方案，如何可以以最短的总公路距离将 所有岛屿联通起来（注意：这是一个无向图）。\n给定一张地图，其中包括了所有的岛屿，以及它们之间的距离。以最小化公路建设长度，确保可以链接到所有岛屿。\n输入描述 第一行包含两个整数V 和 E，V代表顶点数，E代表边数 。顶点编号是从1到V。例如：V=2，一个有两个顶点，分别是1和2。\n接下来共有 E 行，每行三个整数 v1，v2 和 val，v1 和 v2 为边的起点和终点，val代表边的权值。\n输出描述 输出联通所有岛屿的最小路径总距离 输入示例 7 11 1 2 1 1 3 1 1 5 2 2 6 1 2 4 2 2 3 2 3 4 1 4 5 1 5 6 2 5 7 1 6 7 1 输出示例 6 提示信息 数据范围： 2 \u0026lt;= V \u0026lt;= 10000; 1 \u0026lt;= E \u0026lt;= 100000; 0 \u0026lt;= val \u0026lt;= 10000;\n如下图，可见将所有的顶点都访问一遍，总距离最低是6. 解题思路 最小生成树的模板题，这里使用prim算法解决\n代码实现 public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int v = scanner.nextInt(); int e = scanner.nextInt(); int x,y,val; //记录图的邻接矩阵 int[][] grid = new int[v+1][v+1]; while(e -- \u0026gt; 0) { x = scanner.nextInt(); y = scanner.nextInt(); val = scanner.nextInt(); grid[x][y] = val; grid[y][x] = val; } //minDist数组 int[] mindist = new int[v+1]; Arrays.fill(mindist, 10001);//初始化 //记录节点是否在最小生成树里 boolean[] isTree = new boolean[v+1]; mindist[1] = 0; for(int i = 1; i \u0026lt; v ; i++) { int cur = -1; int minVal = Integer.MAX_VALUE; //第一步 for(int j = 1; j \u0026lt;= v ; j++) { if(!isTree[j] \u0026amp;\u0026amp; mindist[j] \u0026lt; minVal) { minVal = mindist[j]; cur = j; } } //第二步 isTree[cur] = true; //第三步 for(int j = 1 ; j \u0026lt;= v; j++) { if(!isTree[j] \u0026amp;\u0026amp; grid[cur][j] \u0026lt; mindist[j]) { mindist[j] = grid[cur][j]; } } } int result = 0; for(int i = 2 ; i \u0026lt;= v; i++) { result += mindist[i]; } System.out.println(result); }\tkruskal算法 kruskal的思路：\n边的权值排序，因为要优先选最小的边加入到生成树里 遍历排序后的边 如果边首尾的两个节点在同一个集合，说明如果连上这条边图中会出现环 如果边首尾的两个节点不在同一个集合，加入到最小生成树，并把两个节点加入同一个集合 kruskal算法\n寻宝 和上题同题\n代码实现 public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int v = scanner.nextInt(); int e = scanner.nextInt(); int result = 0; DisjointSet ds = new DisjointSet(v); //使用并查集实现查看节点是否在同一集合 ds.init(); //存储节点和边权值的结构 List\u0026lt;Edge\u0026gt; edgeList = new ArrayList\u0026lt;Edge\u0026gt;(); for(int i = 0 ; i \u0026lt; e ; i++) { int l = scanner.nextInt(); int r = scanner.nextInt(); int val = scanner.nextInt(); edgeList.add(new Edge(l, r, val)); } // 执行对边权值的排序 edgeList.sort(Comparator.comparingInt(edge -\u0026gt; edge.val)); for(Edge edge : edgeList) { //如果节点不在同一集合 if(!ds.isSame(edge.l, edge.r)) { //结果加入当前权值 result += edge.val; //节点加入集合 ds.join(edge.l, edge.r); } } System.out.println(result); }\t}\tclass DisjointSet{ int n; int[] father; public DisjointSet(int n) { this.n = n; this.father = new int[n+1]; } public void init() { for(int i = 1 ;i \u0026lt; father.length; i++) { father[i] = i; } } public void join(int u, int v) { u = find(u); v = find(v); if(u == v)return; father[v] = u; } public int find(int u) { return (u == father[u])? u: (father[u] = find(father[u])); } public boolean isSame(int u, int v) { u = find(u); v = find(v); return u == v; } //找到需要删除的那条边 public void getRemovedEdge(ArrayList\u0026lt;int[]\u0026gt; edge) { init();//注意每次都要初始化并查集 for(int i = 0 ; i \u0026lt; edge.size() ; i++) {//遍历所有边 if(isSame(edge.get(i)[0], edge.get(i)[1])) {//并查集里有，说明这条边就是要删除的边 System.out.println(edge.get(i)[0]+\u0026#34; \u0026#34;+edge.get(i)[1]); return; }else { join(edge.get(i)[0], edge.get(i)[1]); } } } public boolean isTreeAfterRemoveEdge(ArrayList\u0026lt;int[]\u0026gt; edge, int deleteEdge) { init();//注意每次都要初始化并查集 for(int i = 0 ; i \u0026lt; n; i++) { if(i == deleteEdge)continue; if(isSame(edge.get(i)[0], edge.get(i)[1])) { //说明此时构成了环，不删deleteEdge而是删后一条 return false; } join(edge.get(i)[0], edge.get(i)[1]); } return true; } } class Edge{ int l,r,val; public Edge(int l, int r, int val) { this.l = l; this.r = r; this.val = val; } } 拓展1 题目要求将最小生成树的边输出的话，应该怎么办呢？\nKruskal 算法 输出边的话，相对prim 要容易很多，因为 Kruskal 本来就是直接操作边，边的结构自然清晰，不用像 prim一样 需要再将节点连成线输出边 （因为prim是对节点操作，而 Kruskal是对边操作，这是本质区别）\n当判断两个节点不在同一个集合的时候，这两个节点的边就加入到最小生成树\n拓展2 什么情况用哪个算法更合适呢。\nKruskal 与 prim 的关键区别在于，prim维护的是节点的集合，而 Kruskal 维护的是边的集合。 如果 一个图中，节点多，但边相对较少，那么使用Kruskal 更优。\n在节点数量固定的情况下，图中的边越少，Kruskal 需要遍历的边也就越少。\n而prim 算法是对节点进行操作的，节点数量越少，prim算法效率就越优。\n所以在 稀疏图中，用Kruskal更优。 在稠密图中，用prim算法更优。\n==边数量较少为稀疏图，接近或等于完全图（所有节点皆相连）为稠密图==\nPrim 算法 时间复杂度为O(n^2)，其中 n 为节点数量，它的运行效率和图中边树无关，适用稠密图。\nKruskal算法 时间复杂度 为 nlogn，其中n 为边的数量，适用稀疏图。\n","date": "2025-06-12T00:00:00+00:00",
      "updated": "2025-06-15T14:39:54+08:00"
    }, 
    {
      "objectID": "32e32753f52fbaf154fe153782b5c8be-en",
      "lang": "en",
      "permalink": "https://wittleLuna.github.io/en/post/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/",
      "title": "Backtracking-algorithm","content": "回溯和递归相辅相成，本质上是暴力查找算法(穷举)，所有的回溯法都可以抽象为树形结构\n回溯法，一般可以解决如下几种问题：\n组合问题：N个数里面按一定规则找出k个数的集合 切割问题：一个字符串按一定规则有几种切割方式 子集问题：一个N个数的集合里有多少符合条件的子集 排列问题：N个数按一定规则全排列，有几种排列方式 棋盘问题：N皇后，解数独等等 模板框架:\nvoid backtracking(参数) { if (终止条件) { 存放结果; return; } for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) { 处理节点; backtracking(路径，选择列表); // 递归 回溯，撤销处理结果 } } 回溯三部曲: 1.确定递归函数的参数和返回值 2.确定递归的终止条件 3.确定单层搜索的逻辑\n一般返回值都为void\n组合问题 ==需要startIndex来保证元素不被重复选取==\n组合 给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。\n你可以按 任何顺序 返回答案。\n示例 1：\n输入：n = 4, k = 2 输出： [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4], ]\n确定参数和返回值： 参数：n:代表遍历的次数 k:代表需要走到的深度 startIndex: 代表当前层的遍历位置(因为是组合问题，每个节点只能从其之后的位置开始遍历)\n返回值：none, 使用全局遍历存储结果和当前路径的元素\n确定递归终止条件： 如果当前路径的元素=当前的深度 ： 说明找到的元素个数符合要求，那么把当前路径作为一种结果加入结果变量，之后返回 确定单层的递归逻辑： for循环，加入当前的元素，之后递归进行下一层循环，注意循环开始的位置，之后回溯去掉当前加入的元素（删除当前元素，之后回溯加入其他元素） …","date": "2025-06-11T00:00:00+00:00",
      "updated": "2025-06-15T14:39:09+08:00"
    }, 
    {
      "objectID": "190c022a65c850da958a8f1d779e5475-en",
      "lang": "en",
      "permalink": "https://wittleLuna.github.io/en/post/%E9%98%85%E8%AF%BB%E8%A7%A6%E5%8F%91%E8%AF%8D/",
      "title": "Summary of IELTS Reading Judgment Items","content": " 📘 雅思阅读判断题十大陷阱类型 + 触发语速查卡 ✅ 陷阱类型 🚨 特征关键词 🎯 触发语口诀 1️⃣ 主语错配 the author / researchers / experts / some / all “谁说的？别乱代入作者。” 2️⃣ 程度误导 all, always, never, only “看到 always / never，要提高警觉。” 3️⃣ 范围偷换 some ↔ most / people ↔ students “小变大，大变小，一律警惕。” 4️⃣ 时态陷阱 used to / now / recent studies “时间变了，观点也会变！” 5️⃣ 语气反转 however, although, but “but 出没，反转常有。” 6️⃣ 观点 vs 事实 “argue”, “believe” vs “confirm”, “prove” “观点 ≠ 事实，别搞混！” 7️⃣ 模糊词对撞 may, might vs must / will “原文说可能，题干说一定 → FALSE！” 8️⃣ 双面观点 some believe X, others believe Y “题干说一致？直接判 FALSE。” 9️⃣ 同义换骨 “cut costs” vs “save money”, “concerned” vs “worried” “换壳不换意，看透词芯。” 🔟 因果关系误判 “A happened and B happened” ≠ “A caused B” “并列 ≠ 因果，小心脑补！” 触发语 常见误判 正确处理 the country / this practice / such an approach 忽略代词指代的具体对象，觉得信息不明确（误选 NG） 回头找前文最近明确提到的对象，代入判断是否对应 题目中带有“所有人 / 所有人群 / 各种情况 / 所有产品”等广泛词汇，如：people of all ages， all researchers，every city 速查策略：看到“泛指 + 范围大” → 马上警惕：❗这类往往是NG陷阱 应对方法：✅回原文精准找范围，有说“所有年龄”才选True ❌ 原文没有提范围，别自己脑补 → NG！ 分类 典型陷阱 提醒语 逻辑误判：全称 vs 部分 “Only some believe\u0026hellip;” ≠ “Not all believe\u0026hellip;” ≠ “有人反对” 没有反对者就不能判 False！选 NG！ 触发表达 处理方式 看到时间线（Today / However / 1968） 警惕不是说“时间久”，而是“对比不同现象” a lot of / most / many / the majority of 小心！如果原文没有明确数量词，就不能选 True 陷阱类型 关键词 判断原则 绝对化表述 only, all, always, exclusive, must 一旦原文出现“非绝对”例外，就要选False 范围扩大/缩小 mainly vs exclusively, some vs all 稍微夸大/缩小范围都可能导致False 时间变化未察觉 in early times vs later 如果题干忽视了发展变化，易误判为True 题干表达方式 原文缺失要素 答案 某人 was surprised / amazed / shocked / happy / afraid\u0026hellip; 原文没有出现该态度或感受词 NG 明确指某个具体团队或人（如 Shipton’s team）做了某事 原文中没有明确该行为由他们做出 NG 合并了多个要素：主语 + 行为 + 态度 原文中缺少其中任一要素 NG 典型表现 错误判断的原因 题干添加了“谁做了什么” 原文没有明说，但你以为是合理推断 → 选True 原文说“某研究讨论了某变量” 但没有说是“谁做了”或者“是不是作者做的” 题干的范围“比原文窄” = False；比原文“宽”但未明确 = Not Given；完全一致 = True。\n1.先圈出题干关键词，尤其是限定词\n2.如：“written record” → 明确限定是“文字证据”\n3.回原文时，带着关键词去精读，而不是仅靠时间、地点等表层词定位就判断\n4.做题时慢半拍，不轻易下结论，特别是 True/False/Not Given 类型\n1. 📍遇到： 题干中出现 “while doing…”、地点名词 + 动作” 🎯做法：\n明确主句事件发生的 时间 / 地点 是否 重叠\n如果文章明确说另一个地方 / 时间，可果断选 False！\n2.前面夸，后面“yet”转折 → 多半是在暗示没被重视 / 被忽视 / 被忽略\n3.判断题目重点 ：拆主干，扔修饰，试逆推，看主观\n4\n==False：有明确证据否定题干陈述中的某一部分信息==\n==Not Given：有的信息能确认，但题干中有一部分信息无法从文中判断对错,或者原文中没有提及能判断对错的信息==。\n注意用词极端的格外注意：impossible, definite等等\n判断类型 特征 示例 True 题干与原文意思一致 原文说 IBM 节省了 $200M，题干说“节省资金” False 原文和题干意思相反或含有逻辑冲突 原文说“可能有麻烦”，题干说“一定活不了” Not Given 题干信息原文里完全没提或提了但说不全 原文只提 IBM，题干问 Google，有关但未涉及 表达 意思 populations of species have declined 指的是该物种的个体数量减少 number of species has declined 才是你说的“物种数量”减少（生物多样性下降） ==判断题优先看句子层面的字面逻辑 + 语言表达，不要过度技术化或延伸。==\n填空题： 1.找句子主干结构\n2.匹配题干关键词 + 句法结构\n锁定主语 + 动词 + 受词组合\n3.==看到关键词定位后，不急着填空，继续往后读至少一句，找到 主语 + 特征 + 作用 的完整描述，确认空格所填的“是什么”再做判断==。\n4.注意抽象表达的理解 + 合理代入题干语义：\n在这类题中，如果找不到完全字面匹配的关键词 就试着回到题干，把句子结构和逻辑主干再读一遍 再尝试用 “抽象代换法” 去原文中找“说的是这事，但用了别的词”那种句子 5.图表题\n注意图表的表示，图表上所标注的地方的位置，注意理解原段落，不要看到某个词就盲目的选。 例子:\n| 看到 “to” 开头的空格 | 先找句子主语和谓语，再决定“to”后的结构类型 |\n6. 填空题中出现“species, type, variety, form, group”等词 → 必须完整填写\n不能简写为统称（如 cow, plant, language），否则信息精度不足\n若删除、添加、替换了原文中的重要修饰语或限定信息，答案将被判 错误\n7.术语定义类型的填空题:\n类型 例子（填空句式） 冒号结构 ... leads to ___: a serious problem that... 同位语结构 A process called ___ is responsible for... 解释型句式 ___, a phenomenon that causes... 定语后置 ___, which can eventually result in... 定义信号词 Draining peatlands leads to ___, defined as... 对应在原文中出现的线索:\n触发词 示例句式 known as \u0026ldquo;\u0026hellip; in a process known as subsidence.\u0026rdquo; called \u0026ldquo;This is called photoperiodism.\u0026rdquo; termed \u0026ldquo;\u0026hellip; a phenomenon termed ocean acidification.\u0026rdquo; defined as \u0026ldquo;This is defined as thermal expansion.\u0026rdquo; referred to as \u0026ldquo;\u0026hellip; often referred to as desertification.\u0026rdquo; coined the term \u0026ldquo;Darwin coined the term natural selection.\u0026rdquo; 先抓“时态 + 肯定/否定 + 事实 or 预测”三件套\n陷阱类型 表现 ✅ 时态混乱 题目是 现在（is already），原文后半句却是“might be able to” → 表示将来，不能当作答案 ✅ 信息干扰靠太近 Silver-studded Blue 和 UK 紧邻，引导考生下意识选 UK \u0026ldquo;is already\u0026rdquo; / \u0026ldquo;currently\u0026rdquo; / \u0026ldquo;now\u0026rdquo;：一定要对应原文里的现在时态，排除所有“could / might / may / in the future”。\n“某物种 + might be able to\u0026hellip;”：这一定是预测未来，不能对应题干中的“现在能”。\n==注意题目的时间==\n\u0026ldquo;exists solely on a diet of\u0026hellip;\u0026rdquo; → 提取关键词是 diet，不是 exist。\n遇到 “X and ___ are\u0026hellip;” 结构，一定要确保 ___ 填的是 名词/名词短语。\n雅思阅读常考 “eat / feed on / live on / rely on” 结构，转换后都可能变成 diet / dependence / reliance / food source 等词。\n==注意合适的词性==\n🧩 快速扫描口诀（审题 5 步小法则）： 🔢 “主干-动词-比较-指代-抽象” 每一道题目先快速扫以下 5 点：\n找主干：先定“句式结构”再定含义\n动词优先审：时态 + 语气 + 推测性动词\n形容词 / 副词对比非常关键\n关键词定位不能止步于“人名 / 概念”\n题干里的“抽象词”通常隐藏原文对应的“具体细节”\n触发检查点 自问句 说明 名词后面如果是 in __，填的词必须是“导致差异的具体维度” “这些差异是在哪方面发生的？” “status” 是造成差异的维度，\u0026ldquo;disparity\u0026rdquo; 是结果，不是维度 是否有修饰词提示 有没有 \u0026ldquo;\u0026hellip; of ___\u0026rdquo; 提示我被填的词是什么？ 原文里是 \u0026ldquo;disparities of status\u0026quot;，说明 status 是空 原文是否有固定搭配反转结构？ “是不是原文中某个结构前后对调了位置？” 原文：disparities of status don’t arise → 题目：prevent differences in ___ occurring 段落匹配： 如果感觉没有特别匹配字母意思的内容：不要只盯着字面意思，注意隐含表达。 如：a justitication for research into earworms （隐含）-\u0026gt; 能研究，能学到什么？\n注意整段主旨意思，题目包含的是否只是其中一个个例\n触发词 提示作用 Overall, in general, the key advantage is\u0026hellip; 通常是段落中心思想的开头 for instance, such as, e.g., IBM claims\u0026hellip; 后面大概率是细节/例子，不能作为段落标题 can be a great benefit\u0026hellip; 提示段落重心是优点或功能，而非单一公司 干扰选项类型 特征 策略 局部细节型 多媒体、某个公司、具体数据、某一个优点被放大 看清是否是整段核心思想，而不是例子或“提到过” 概念相近型 如“teaching materials”、“future directions”听起来合理 检查段落是否真的谈“未来”或“材料升级”，还是在讲目前的整体“好处” 选择题 触发内容 触发词/句 警惕点 虚拟语气导致的误判 “If we had…”, “Would have been…”, “Had he spoken…” 不代表事实，是“设想”。要回到上下文看真实发生的是什么。 真实情况被悄悄说明 “\u0026hellip;as we are”, “Actually”, “In fact” 等 作者常用“插入语”来说明现实。不要只看假设，要抓住这些 修正语气 的信号。 背景噪音、技术障碍类对话困难 “struggling to hear”, “background noise”, “scratchy line”, “obstacle to communication” 表明不是语言不通，而是听力/信号/技术问题，选项 D 往往正确。 误导性设想 vs 实际正在进行 “He could have spoken in German” vs “He is speaking in English” 要区分设想和现实发生的事，尤其当句子同时出现时（如本题）。 ✅ 使用建议： 做判断题前快速看一眼（5秒刷一遍） 做错后找下错因归类 → 哪类陷阱抓得不牢 一周内多刷几轮，逐渐形成“做题前的脑内雷达” 遇到不懂的词怎么办 主干不懂，不准跳过。 修饰不懂，可以跳过。 不懂词，看后文。 来不及，抓正负。\n","date": "2025-05-20T00:00:00+00:00",
      "updated": "2025-05-20T14:36:58+08:00"
    }, 
    {
      "objectID": "03fcf2da5448523bbd3963d79c22b449-en",
      "lang": "en",
      "permalink": "https://wittleLuna.github.io/en/post/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/",
      "title": "The Introduction of Natural Language Processing (NLP)","content": " 背景知识 自然语言处理(natural language processing, NLP)\nNLP发展历程 阶段一：图灵测试 该测试的流程是，一名测试者写下自己的问题，随后将问题以纯文本的形式（如计算机屏幕和键盘）发送给另一个房间中的一个人与一台机器。测试者根据他们的回答来判断哪一个是真人，哪一个是机器。所有参与测试的人或机器都会被分开。这个测试旨在探究机器能否模拟出与人类相似或无法区分的智能 [1]。 现在的图灵测试测试时长通常为5分钟，如果电脑能回答由人类测试者提出的一系列问题，且其超过30%的回答让测试者误认为是人类所答，则电脑通过测试。\n阶段二：基于规则的方法 自然语言处理的最早阶段主要采用基于规则的方法，通过人工定义语法和规则来解析和生成文本。这些方法的局限性在于难以涵盖语言的复杂性和多样性，因为规则需要人为设计且难以适应不同的语境。\n阶段三：统计学习方法 随着统计学习方法的兴起，自然语言处理进入了统计学习阶段。该阶段的代表性方法包括隐马尔可夫模型（Hidden Markov Models，HMM）和最大熵模型（Maximum Entropy Models）。这些方法通过从大量语料中学习统计规律来解决语言处理问题，提高了模型的泛化能力。\n阶段四：深度学习与神经网络 深度学习的广泛应用推动了自然语言处理领域的进一步发展。循环神经网络（Recurrent Neural Networks，RNN）和长短时记忆网络（Long Short-Term Memory，LSTM）等模型在序列标注、机器翻译等任务上取得了显著的成果。随后，注意力机制和Transformer模型的提出进一步提升了自然语言处理的性能，例如BERT、GPT等模型。\nAI发展历程 第一阶段-AI兴起：人工智能的诞生（1941- 1956）\n第二阶段-AI早期成功：AI黄金发展时代（1956-1974）\n第三阶段-AI第一次寒冬：神经网络遇冷，研究经费减少（1974~1980）\n第四阶段-AI复兴：第二次AI黄金发展时代，专家系统流行并商用（1980~1987）\n第五阶段-AI第二次寒冬：专家系统溃败，研究经费大减（1987~1993）\n第六阶段-AI崛起：深度学习理论和工程突破（1993至今）\n语言模型 用于捕捉自然语言中词汇，短语和句子的概率分布的统计模型。根据给定的上下文，预测接下来出现的单词。\n语料库 大量自然语言文本的集合\n通用领域语料库 特定领域语料库 数据预处理 数据采集：获取文本数据，可以来自各种来源，如网页、社交媒体、新闻文章、文本文件等。数据采集可能需要网络爬虫或API调用。\n文本清洗：清除不需要的字符、符号、HTML标签等。这通常涉及使用正则表达式和文本处理库来进行清洗。清洗后的文本更易于分析和处理。\n分词：将文本分割成单词或标记。分词是将文本数据转化为机器可理解的基本单位，有助于构建词汇表和分析文本结构。\n停用词去除：停用词是常见的无实际信息的词语，如“the”、“and”等。通常需要将它们从文本中去除，以减小词汇表的大小。\n词干提取和词形还原：这有助于将单词还原为其基本形式，以减少词汇多样性。例如，将“running”还原为“run”。\n特征提取：将文本转化为数值特征，例如词袋模型、TF-IDF权重等。这是将文本数据转化为可以用于机器学习模型的数值表示的重要步骤。\n数据标记和标签：对文本数据进行标记和分类，以便用于监督学习任务，如文本分类或命名实体识别。\n统计语言模型的发展历程 出现很早，但由于网络结构和数据量的限制，早期并没有实现突破性应用。存在不少缺点：过拟合，无法处理文本间长距离依赖性等。\n1948 N-Gram模型：基于前N-1个词来预测第N个词\n1954 Bag-of-word模型: 将一个句子或文档表示为单词的集合，不考虑单词在文本中的顺序。不能捕捉语义语法信息。\n1986 分布式表示法：将单词或短语表示为数值向量的方法。具有较多的语法和句意信息。解决了Bag-of-Word模型和独热编码中的词汇鸿沟问题。\n2003 神经概率语言模型: 通过神经网络对语言进行建模\n2013 WordtoVec: 通过训练神经网络模型来学习词汇的分布式表示，简单又高效。两种架构：CBOW模型和Skip-Gram模型。可以捕捉到单词之间的相似性和语义语法信息。\n2018以后 基于Transformer的预训练语言模型：通过更大的语料库和更复杂的神经网络体系结构来进行语法语义的学习\n基于Transformer框架的预训练语言模型 自然语言处理中的预训练，通常指在大量无标注文本数据上训练语言模型。预训练所得的大规模语言模型也被叫做‘基础模型’。\n在预训练过程中，模型学习了词汇，语法，句子结构及上下文信息等语言知识。这种知识为后续下游任务提供了一个通用的，丰富的语言表示基础，为解决许多复杂的NLP问题提供了可能。\nBERT,GPT BERT和GPT的区别主要有三点：\n训练目标：BERT使用双向上下文进行掩码语言建模，而GPT通过单向自回归预测下一个词。 架构：BERT基于Transformer编码器，关注上下文理解；GPT基于Transformer解码器，侧重文本生成。 应用场景：BERT擅长文本分类、问答等理解任务，GPT更适合文本生成、续写等创作任务。 预训练+微调大模型 预训练:大量无标注文本数据 -\u0026gt; fine-tuning(微调)：创建带有相应标签的数据集\n大模型应用方式: fine-tuning, RAG(检索增强生成), Agent(智能体), workflow,prompt(提示词工程)，蒸馏\n以提示/指令模式使用大模型 prompt/instruct模式和\u0026rsquo;预训练+微调大模型\u0026rsquo;的异同\n预训练+微调大模型：通过在特定任务上对模型进行微调，使得模型更加精确适应任务需求 prompt/instruct模式：直接利用预训练语言模型的生成能力，更加灵活 GPT 目标：最大化语句序列出现的概率\n自然语言处理(NLP)常见任务 基础任务：分词、词性标注、命名实体识别（NER）、句法分析（依存/成分句法）。 语义理解：语义角色标注、词义消歧、语义相似度计算、文本蕴含判断。 文本分类：情感分析、主题分类、垃圾邮件检测、意图识别。 生成与翻译：机器翻译、文本摘要、对话生成、文本续写（如GPT）。 信息抽取：关系抽取、事件抽取、关键词提取、知识图谱构建。 问答系统：开放域问答、阅读理解（如SQuAD）、FAQ匹配。 应用任务：文本纠错、文本聚类、推荐系统、多模态交互（文本+图像/语音）。 百炼平台 云工开物 wildcard 语言模型基础 词表\n定义和作用：从语料库中提取的词汇集合，是将文本转换为数值形式（词向量，索引序列）的基础\n构建要点：\n词频统计 词表大小选择 特殊标记 未登录词 在自然语言处理（NLP）中，未登录词（Out-of-Vocabulary, OOV） 是指未被预先构建的词表（Vocabulary）或训练数据覆盖的词语。这类词会导致模型无法有效处理，常见原因包括：\n新词：如网络流行语（“绝绝子”）、专业术语或领域专有名词。 形态变化：如英文的“unhappiness”（若词表仅含“happy”）。 拼写错误：如“teh”代替“the”。 低频词：在训练数据中出现次数过少而被过滤的词。\n影响：OOV会降低分词、词性标注、翻译等任务的性能。例如，中文分词可能因未登录词导致切分错误。\n停用词 在自然语言处理（NLP）中，停用词（Stop Words） 是指文本中频繁出现但语义贡献较低的词，通常会被预处理阶段过滤以提升模型效率。例如：\n常见停用词： 中文：的、了、是、在、和、而等。 英文：the, a, an, and, is, of 等。\n核心作用： 降噪：减少无意义词对文本分类、情感分析等任务的干扰。 节省资源：降低特征维度，加速模型训练（如TF-IDF或词袋模型）。 提升效果：避免高频词掩盖关键语义（如搜索索引中优先匹配内容词）。\n应用场景： 需要过滤：文本分类、搜索引擎、主题建模（如LDA）。 可能需要保留：对话系统（如“不”、“吗”影响语气）、某些实体识别任务（如“和”连接人名）。\n分词 将连续的文本序列拆分成较小的基础单位（单词，子词或字符）的过程。分词方式会根据语言和应用场景有所不同。\n重要性\n分词是文本预处理的首要步骤，直接影响词表构建，词向量训练和后续模型对语义的理解 合理分词可以减少噪声，降低数据维度，使模型更加高效 Embedding 技术 将高维数据映射到低维空间的方法，通过将复杂，离散的数据(文本，图像，网络)转换为连续的数值向量表示，使计算机能够处理和分析数据\n训练 和 预训练的区别 训练 垂直领域数据\n预训练 通用领域数据\n","date": "2025-02-25T00:00:00+00:00",
      "updated": "2025-02-25T14:36:58+08:00"
    }, 
    {
      "objectID": "2fbcaeed0e4e4f766e1e6c76b77dff9b-en",
      "lang": "en",
      "permalink": "https://wittleLuna.github.io/en/post/%E8%93%9D%E6%A1%A5%E6%9D%AF%E4%BB%8B%E7%BB%8D/",
      "title": "[LanQiao CUP]Introduction","content": " 蓝桥杯介绍 蓝桥杯赛制 IO赛制\n赛制特点： 个人赛：每个选手独立参赛。 比赛时长：4小时。 题目数量：通常8-10道题。 答题方式：选手每题可提交多次，但==仅保留最后一次提交结果，比赛期间无法看到评测结果==。 题目类型：单结果题+编程题。单结果题：只需要输出题目问题的答案。编程题：有多个测试点，每个测试点有一个正确答案。 评分规则：每道题包含多个测试点，根据通过的测试点数量得分，部分数据通过也能获得部分分数。最终得分在赛后公布。\nOI赛制最大的特点在于考试的时候看不到评测结果，不像ACM赛制可以立马看到结果，知道自己对不对，但是好处是有部分分，过了几个点也有分拿。\n图例[19728 拼十字]\n官网题库练习界面，有调试和提交检测按钮。调试按钮使用第一个节点的测试数据测试程序能不能得到正确结果，提交检测会检测所有测试数据，最后给出完整的结果。 怎样的答案才算是正确答案？ 1.程序逻辑正确 2.满足时间复杂度和空间复杂度的要求\n根据选择使用的算法不同，复杂度不同，通过率会有差别。20个检测点，使用回溯算法，通过6个，得6分。\n==在正式比赛中，需要在指定位置上传自己的程序代码。看不到提交后的结果，不能进行调试。检测方法就是根据题目要求，自己想例子手动测试。==\n蓝桥杯常用数据结构 列表(数组) 特点： 连续存储，支持随机访问，索引复杂度为 \\(O(1)\\)。 插入、删除复杂度为 \\(O(n)\\)。 应用场景： 简单的序列存储（如题目输入输出）。 作为动态数组的基础结构。 蓝桥杯常见题型： 前缀和：求连续子数组的和。 双指针：查找满足条件的子数组或子序列。 例题： 给定一个数组，找到和为目标值的连续子数组。 给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的子数组的个数 。\n子数组是数组中元素的连续非空序列。\n示例 1：\n输入：nums = …","date": "2025-01-22T00:00:00+00:00",
      "updated": "2025-01-22T14:36:58+08:00"
    }
]
