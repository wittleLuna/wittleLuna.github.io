[
    {
      "objectID": "5840f0be3985306ab2f1b5cca4f9f6c9-en",
      "lang": "en",
      "permalink": "https://wittleLuna.github.io/en/post/%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/",
      "title": "[Basic knowledge]Data Structure and Algorithms","content": " 数据结构和算法 经典算法题 字符串匹配问题： 暴力匹配 KMP算法 八皇后：回溯算法 汉诺塔：分治算法 马踏棋盘：图的深度优化遍历算法(DFS)+贪心算法\n线性结构和非线性结构 数据结构包括线性结构和非线性结构\n线性结构 最常用的线性结构\n特点：数据之间存在==一对一==的线性关系\n存储结构：\n顺序存储结构（数组）：顺序存储的线性表称为顺序表，==顺序表中的存储元素是连续的（内存分配的地址是连续的）==\n链式存储结构（链表）：链式存储的线性表称为链表，==存储元素不一定连续==\n常见的线性结构：数组，队列，链表，栈\n非线性结构 不是一对一的关系\n常见的非线性结构：二维数组，多维数组，广义表，树结构，图结构\n稀疏数组和队列 稀疏数组(sparseArray) 如：用二维数组记录棋盘数据，有很多0，记录了很多没有意义的数据 基本介绍： 当一个数组中大部分元素是0，或者为同一个值的数组时，可以使用稀疏数组来保存数组。\n稀疏数组的处理方法：\n1.记录数组一共有几行几列，有多少个不同的值\n2.把具有不同值的元素的行列及值记录在一个小规模数组中，从而缩小程序的规模\n稀疏数组转二维数组：\n1.遍历原始二维数组，得到有效数据的个数sum\n2.根据sum创建sum创建sparsearr int[sum + 1][3]\n3.将二维数组的有效数据存到一维数组\n二维数组转稀疏数组：\n1.先读取稀疏数组的第一行，根据第一行的数据，创建原始二维数组\n2.再读取稀疏数组后几行的数据，并赋给原始的二维数组\n代码实现 package sparsearray; public class SparsearrDemo1 { public static void main(String[] args) { int[][] arr = new int[11][11]; arr[1][2] = 1; …","date": "2025-06-14T00:00:00+00:00",
      "updated": "2025-06-15T14:39:44+08:00"
    }, 
    {
      "objectID": "3ec19241c503f5bfa4d6d6cd12368936-en",
      "lang": "en",
      "permalink": "https://wittleLuna.github.io/en/post/huggingface-%E4%B9%8B-%E4%BD%BF%E7%94%A8space-%E5%88%9B%E5%BB%BA%E8%81%8A%E5%A4%A9%E7%A8%8B%E5%BA%8F/",
      "title": "[Huggingface] How to build your space","content": " 简单介绍 Hugging Face, Inc. is a French-American company based in New York City that develops computation tools for building applications using machine learning. It is most notable for its transformers library built for natural language processing applications and its platform that allows users to share machine learning models and datasets and showcase their work.\n简单来说就是一个社区，它提供了服务器的功能，用户可以把自己建立的应用，模型等通过它的服务能够在公网进行访问和使用\n前提准备 huggingface, github账号 第一步 建立新的space 在这里选择new space, 可以看到huggingface还支持建立模型，数据集等，这些目前用不到\n这一步需要填写下列内容 你的空间名称\n对空间的描述\n许可，这里可默认不写\n选择空间的SDK, 这一步很关键，决定了你的空间是何种类型的;可以看到我们可以使用Gradio构建web应用，用HTML构建静态内容，或者使用Docker拉取镜像。\n这里Huggingface提供了很丰富的不同版本的内容，可按照个人喜好自由选择 公开/私有： 决定你的空间是否别人能够访问\n第二部，配置 Space 以我这里选择Gradio为例（不同类型流程也是一样的），你现在需要做的事情有：\n克隆space到自己的Github仓库\n创建/修改克隆到仓库中的文件内容，以符合你的需要\n如图，这是我的space项目，我简单修改了其中的app.py内容，使其能够通过我的Key访问大模型，实现简单的AI问答功能 我这里通过 Github 的 codespace功能， 很方便就能实现对文件的修改和上传功能，而且其布局也和Vscode完全一致 当你完成后，需要把这些文件push到space中，完成对space内容中的更新：\n具体推送需要用到的指令如下： git add . git remote add origin-hf https://huggingface.co/spaces/wittleLuna/Test git commit -am \u0026#34;app.py requirements.txt(例子，这里写你的文件名)\u0026#34; git push origin-hf main --force 具体解释： git add . 意思： 把当前目录下的所有改动文件（包括新建的）添加到 Git 暂存区（staging area）。\n用途： 你必须先 add，才能 commit。这一步表示“我准备提交这些文件”。\ngit remote add origin-hf https://huggingface.co/spaces/wittleLuna/Test 意思： 为当前 Git 仓库添加一个远程地址，名字叫 origin-hf，对应的是 Hugging Face Spaces 上你的 Space 项目的 Git 地址。\n用途： 以后你可以使用这个名字 origin-hf 来 push 或 pull 到这个 Hugging Face Space。\n🧠 类似于给 Git 起了个别名：origin-hf 指向 Hugging Face Space。\ngit commit -am \u0026quot;app.py requirements.txt(例子，这里写你的文件名)\u0026quot; 意思： 把你暂存的更改保存为一次“提交”，并附上提交信息（备注说明）：\n-a：自动将修改过的文件加入提交（不包含新文件） -m：后面跟的是提交信息，比如你改了哪些文件 ⚠️ 注意：新建文件（没 git add 过）不会被 -a 自动提交，仍需手动 git add . 先添加。\ngit push origin-hf main --force 意思： 将本地的 main 分支强制推送到 Hugging Face 的远程 origin-hf 仓库（覆盖远程内容）。\n--force：如果远程仓库已有内容（比如模板代码），这会强制覆盖。 ⚠️ 风险：--force 会覆盖远程仓库的历史，建议只有你明确知道要“重新上传整个 Space 项目”时才用它。\n第三步 Space运行上线 当你成功上传了文件后，在你的space 页面的上方的no application file将进入运行状态，类似与服务器，你可以从旁边的log查看日志，以便排查错误。\n现在只需要耐心等待space构建完毕，你自己的space项目便上线可用了！只要你设置为了Public,所有人都可以通过你的Space地址来使用。\n这里是我构建的简单AI问答space,你也可以考虑实现更复杂功能的space。 ","date": "2025-06-14T00:00:00+00:00",
      "updated": "2025-06-15T14:38:34+08:00"
    }, 
    {
      "objectID": "33f933bd343a607362e0b249de0590ec-en",
      "lang": "en",
      "permalink": "https://wittleLuna.github.io/en/post/openwebui-%E4%B9%8B-%E4%BD%BF%E7%94%A8pipeline-%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9E%8B%E8%B0%83%E7%94%A8/",
      "title": "[Openwebui] How to use pipeline","content": " 方法一： 用 Docker 容器运行 Pipelines docker run -d -p 9099:9099 \\ --add-host=host.docker.internal:host-gateway \\ -v /home/yourname/my-pipelines:/app/pipelines \\ --name pipelines \\ --restart always \\ ghcr.io/open-webui/pipelines:main 这种方法直接使用官方预构建的 Docker 镜像，自动加载 /app/pipelines 路径下的 pipeline 文件；将你写好的 pipeline 挂载进去即可使用\n官方镜像下载慢，但是华为云又版本过低？没事，这里我已经帮你找到了南京大学的镜像，速度快，版本新，十分甚至九分的好用\nghcr.nju.edu.cn/open-webui/pipelines:main 方法二： 本地部署pipelines 第一步：克隆官方pipeline仓库 git clone https://github.com/open-webui/pipelines.git cd pipelines python3.11 -m venv venv source venv/bin/activate pip install -r requirements.txt 注意的点 关于 clone github 仓库 如果你拥有自己的服务器，可以在云端进行。而且vscode支持远程连接时git 仓库，很方便（可能需要科学上网），也可以选择先克隆到本地，再把写好的文件上传到云端服务器\n关于 requirement.txt 需要rustc和cargo的支持，需要先下载rust。直接安装依赖可能报错 第二步：创建 rag_pipeline.py 文件 📁 在 pipelines/ 目录下新建：\n# pipelines/rag_pipeline.py from openwebui.pipelines import PipelineStep from rag_report_generator import ReportGenerator class RAGPipeline(PipelineStep): def __init__(self): # 保留你原来的逻辑 self.generator = ReportGenerator() def run(self, data: dict) -\u0026gt; dict: query = data.get(\u0026#34;user_input\u0026#34;, \u0026#34;\u0026#34;) # OpenWebUI 会传 user_input result = self.generator.generate_report(query) return { \u0026#34;response\u0026#34;: result # 返回给前端 } 代码片段，仅供参考。\n这里的自定义pipeline可参考 (https://github.com/open-webui/pipelines/blob/main/examples/pipelines)中官方的pipeline写法\n第三步：启动 Pipelines 服务 sh ./start.sh 成功后会默认监听：\nhttp://localhost:9099/v1/chat/completions 你可以在浏览器尝试访问 http://localhost:9099/docs 查看接口文档是否加载。\n这种方法会启动本地 Python 脚本，运行一个 FastAPI 服务，监听 9099 端口,会自动加载你本地 pipelines/ 文件夹中的所有 pipeline 文件（.py）\n适合场景：\n开发者在调试自定义 pipeline；\n不想用 Docker 或暂时测试环境未准备好；\n更灵活，便于打 log 和调试。\n额外注意事项\n请仔细查看openwebui的官方文档，是否正确安装了所需的依赖和所需的python版本，其中提到3.11是唯一支持的python版本！\n在 OpenWebUI 设置中绑定 Pipelines 打开 OpenWebUI Web 页面\n进入 设置 → 外部连接\n添加一个模型：\nURL填写：http://\u0026lt;你的服务器地址\u0026gt;:9099/ 密钥： 0p3n-w3bu! 你会看到有一个图标显示在该连接上，说明你的pipeline连接成功了\n上传本地/从GitHub上下载pipeline\n现在你可以从模型列表中看到pipeline, 可以直接与其对话\n","date": "2025-06-14T00:00:00+00:00",
      "updated": "2025-06-15T14:38:47+08:00"
    }, 
    {
      "objectID": "9857ac6b72a87029be956f036d9ee5d4-en",
      "lang": "en",
      "permalink": "https://wittleLuna.github.io/en/post/%E8%93%9D%E6%A1%A5%E6%9D%AF%E9%94%99%E8%AF%AF%E6%80%BB%E7%BB%93%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/",
      "title": "algorithm questions of lanqiao cup","content": " 杂题 105 油漆面积 错误描述 ： 发生了段错误\n原因： 保持二维数组时使用了int数组，一个int占4字节。10004*10004(个int类型变量) * 4 (转换成字节) / 1000 (转换为kb/千字节) / 1024 (转换为mb) 约为390mb， 远超题目最大运行内存256mb,所以会报段字节的错误\n解决方法： 使用占用内存更小的类型，如boolean,占用1个字节\n代码实现\npublic static void main(String[] args) { Scanner scan = new Scanner(System.in); int n = scan.nextInt(); ArrayList\u0026amp;lt;int[]\u0026amp;gt; rectangles = new ArrayList\u0026amp;lt;\u0026amp;gt;(); boolean[][] grid = new boolean[10004][10004]; for(int i = 0 ; i \u0026amp;lt; n ; i++) { int x1 = scan.nextInt(); int y1 = scan.nextInt(); int x2 = scan.nextInt(); int y2 = scan.nextInt(); int temp = 0; if(x1 \u0026amp;gt; x2) { temp = x2; x2 = x1; x1 = temp; } if(y1 \u0026amp;gt; y2) { temp = y2; y2 = y1; y1 = temp; } rectangles.add(new int[]{x1,y1,x2,y2}); } for(int[] arr: rectangles) { for(int x = arr[0]; x \u0026amp;lt; arr[2]; x++) { for(int y = arr[1]; y\u0026amp;lt; …","date": "2025-06-14T00:00:00+00:00",
      "updated": "2025-06-15T14:40:07+08:00"
    }, 
    {
      "objectID": "72a54093b13861d65bc821ddb8913c16-en",
      "lang": "en",
      "permalink": "https://wittleLuna.github.io/en/post/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/",
      "title": "dynamic programming","content": " 动规五部曲 确定dp数组和下标的含义 写出递推公式 确定dp数组如何初始化 确定遍历顺序（方向） 打印，举例推导验证dp数组是否正确 背包问题 01背包 可使用二维背包，一维滚动背包 二维背包 基本了解 基本递推公式 : dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]]+value[i])\ndp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少\n遍历顺序一般是先物品，再背包。也可以先背包，再物品\n第一列初始化为0，第一行为第一个物品能否装入的价值\ndp的方向是由左上方决定的，遍历顺序从前往后/从后往前都可以\n一维背包/滚动背包 基本递推公式 : dp[j] = max(dp[j],dp[j - weight[i]] + value[i]) 需要先遍历物品，再遍历背包，遍历背包时要倒序遍历 初始化为0 dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j] 为什么背包容量循环需要倒序： dp[j - weight[i]] + value[i] : 说明是从左边的值来寻找当前合适的值\n如果倒序，此时j从大到小，从左边：左边初始化都为0，所以不会使用到已经用过的物品\n如果顺序，此时j从小到大，从左边：假如已经填了第一个物品，那么第二次，查找左边，就会继续把第一个物品的值加上\n题型类型 1.纯01背包，计算背包装满的最大价值\n2.能否填满背包（一般背包容量也可以是指定数字，数组里的数作为元素，能否达到指定数字）\n不同点：返回值是和需要的容量作比较后的布尔值 3.尽量填满背包\n4.填满背包的方法数量\n不同点 ：\n1.递推公式不同: 总填充方法 = 不要该物品的填充方法+空出该物品容量，要该物品的填充方法，以及分支条件，如果装不下该物品，采用之前的填充方法数\ndp[j] += dp[j - weight[i]]\n2.初始化方式不同：第一行为第一个物品填满该容量的方法，第一列为1（空容量，不放物品有一种方法）\n5.填二维背包（有两种重量）\n不同点：\n1.递推公式不同，因为是二维背包，所以需要减去两个维度的重量:dp[i][j] = max(dp[i][j], dp[i-weight[x]][j-weight[y]]) 2.遍历背包容量时，从后向前遍历\n多重背包 有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品都有无限个（也就是可以放入背包多次），求解将哪些物品装入背包里物品价值总和最大。\n和01背包不同的是：此时内层for循环的顺序为从小到大，无需倒序 背包容量和物品的先后顺序决定是求组合数还是求排列数 先物品 后背包 : 组合数 先背包 后物品 ：排列数 完全背包 有N种物品和一个容量为V 的背包。第i种物品最多有Mi件可用，每件耗费的空间是Ci ，价值是Wi 。求解将哪些物品装入背包可使这些物品的耗费的空间 总和不超过背包容量，且价值总和最大。\n把每件物品看作一件，就是01背包问题 打家劫舍 子序列问题 常见题目类型 单序列的判断： 【最长递增子序列】 示例 1： 输入：nums = [10,9,2,5,3,7,101,18] 输出：4 解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。\n不要求是子数组，但要求子序列中的数严格递增\ndp的定义 ： i之前，包括i,以nums[i]为结尾的最长递增子序列的长度\n递推公式 :\n使用两层for循环，外层作为当前循环到的元素nums[i],内层作为其之前的数nums[j]\n位置i的最长升序子序列等于j从0到i-1各个位置的最长升序子序列 + 1 的最大值\n判断是否当前nums[i] \u0026gt; nums[j]\ndp[i] = max(dp[i] + 1 , dp[i])\n初始化：\n全都初始化为1，单个子序列 结果 ： 根据dp数组的定义，结果并不是在dp[length-1]中，而是要在循环里寻找以某个nums[i]为结尾的最大值\n【最长连续递增子序列】 示例 1： 输入：nums = [1,3,5,4,7] 输出：3 解释：最长连续递增序列是 [1,3,5], 长度为3。 尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。\n与上一题相比，多了连续,说明要按照数组中的数字顺序严格递增\n只需要判断当前nums[i]的前一个数nums[i-1],无需再遍历之前所有数\ndp的定义和上一题相同\n递推公式：\n只需要判断if(nums[i] \u0026gt; nums[i - 1]),无需第二层循环 【最大子数组和】 给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n子数组 是数组中的一个连续部分。\n示例 1：\n输入：nums = [-2,1,-3,4,-1,2,1,-5,4] 输出：6 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。\n和 【最长递增子序列】 类似， 不需要连续，但是求最大的和，而不是最长有多少个\ndp定义也差不多相同 ：以下标i(nums[i])为结尾的最大连续子序列和为dp[i]\n递推公式\n不需要判断 dp[i] = max(dp[i - 1] + nums[i] , dp[i]) 有可能当前的比之前的大，所以要取最大值 同理，最后的结果不再最后一个dp[length-1]中\n双序列的判断 【最长重复子数组】 给两个整数数组 nums1 和 nums2 ，返回 两个数组中 公共的 、长度最长的子数组的长度 。\n示例 1： 输入：nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7] 输出：3 解释：长度最长的公共子数组是 [3,2,1] 。\n==dp数组的定义 ： 以i-1为结尾的nums1[i-1] 和 以 j-1 为结尾的nums2[j-1] 的最长重复子数组为dp[i][j]== ==为什么要定义为i-1,j-1而不是i,j : 省去了初始化时的麻烦，直接初始化为0就可以了== 如果定义 dp[i][j]为 以下标i为结尾的A，和以下标j 为结尾的B，那么 第一行和第一列毕竟要进行初始化，如果nums1[i] 与 nums2[0] 相同的话，对应的 dp[i][0]就要初始为1， 因为此时最长重复子数组为1。 nums2[j] 与 nums1[0]相同的话，同理。\n需要判断的是两数组当前以i-1,j-1为结尾时的子数组是否相同，相同说明此时是重复数组 递推公式 ： for循环 ： 两次，从1开始，结束条件为\u0026lt;=length, 是根据dp数组的定义决定的\n判断条件 : nums1[i-1] == nums[j-1]\ndp[i][j] = dp[i-1][j-1] + 1\n注意最后的结果不在dp[length][length] 而是在循环中某处得到的最大值 【最长公共子序列】 给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。\n一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。\n例如，\u0026ldquo;ace\u0026rdquo; 是 \u0026ldquo;abcde\u0026rdquo; 的子序列，但 \u0026ldquo;aec\u0026rdquo; 不是 \u0026ldquo;abcde\u0026rdquo; 的子序列。 两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。\n示例 1：\n输入：text1 = \u0026ldquo;abcde\u0026rdquo;, text2 = \u0026ldquo;ace\u0026rdquo; 输出：3\n解释：最长公共子序列是 \u0026ldquo;ace\u0026rdquo; ，它的长度为 3 。\n和 【最长递增子序列 】 类似， 不过是两个数组。\n不要求是公共子序列（不严格递增）\ndp数组的定义:长度为[0, i - 1]的字符串text1与长度为[0, j - 1]的字符串text2的最长公共子序列为dp[i][j]\n递推公式 ：\n需要在上一题的基础上加上进一步判断如果当时两个数不相同的条件 如果相同， 和上一道题相同 dp[i][j] = dp[i-1][j-1] + 1 如果不相同，在两个数组之前拿到的最大值中取最大的一个 dp[i][j] = max(dp[i-1][j], dp[i][j-1]) 注意此时是从[0 - i]的最大值，所以本题的最大值就在dp[length][length]里\n【不相交的线】 在两条独立的水平线上按给定的顺序写下 nums1 和 nums2 中的整数。\n现在，可以绘制一些连接两个数字 nums1[i] 和 nums2[j] 的直线，这些直线需要同时满足：\nnums1[i] == nums2[j] 且绘制的直线不与任何其他连线（非水平线）相交。 请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。\n以这种方法绘制线条，并返回可以绘制的最大连线数。\n示例 1：\n输入：nums1 = [1,4,2], nums2 = [1,2,4] 输出：2 解释：可以画出两条不交叉的线，如上图所示。 但无法画出第三条不相交的直线，因为从 nums1[1]=4 到 nums2[2]=4 的直线将与从 nums1[2]=2 到 nums2[1]=2 的直线相交。\n其实就是求最长公共子序列 【判断子序列】 给定字符串 s 和 t ，判断 s 是否为 t 的子序列。\n字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，\u0026ldquo;ace\u0026quot;是\u0026quot;abcde\u0026quot;的一个子序列，而\u0026quot;aec\u0026quot;不是）。\n示例 1：\n输入：s = \u0026ldquo;abc\u0026rdquo;, t = \u0026ldquo;ahbgdc\u0026rdquo; 输出：true\n和 【最长公共子序列】 类似，不过本题只需要删除t，s不动 dp数组的定义和 【最长公共子序列】 相同 递推公式： 此时的else分支条件发生变化: 原是 ： dp[i][j] = max(dp[i-1][j], dp[i][j-1]) 此时 ： dp[i][j] = dp[i-1][j] (i作为代表t的数组时) 解释 ： 如果此时两字符串的最后一个字符不相同，那么就需要减去t当前的字符，把dp[t-1]中的内容作为最大值。而s不能变。 结果 ： 判断最后结果是否等于s字符串的长度 【不同的子序列】 给你两个字符串 s 和 t ，统计并返回在 s 的 子序列 中 t 出现的个数，结果需要对 109 + 7 取模。\n示例 1：\n输入：s = \u0026ldquo;rabbbit\u0026rdquo;, t = \u0026ldquo;rabbit\u0026rdquo; 输出：3 解释： 如下所示, 有 3 种可以从 s 中得到 \u0026ldquo;rabbit\u0026rdquo; 的方案。 rabbbit rabbbit rabbbit\n和 【判断子序列】 , 【最长公共子序列】 类似 , 不过改成了求出现的个数，而不是最长有多长\ndp[i][j]：以i-1为结尾的s子序列中出现以j-1为结尾的t的个数为dp[i][j]。\n递推公式\nif(s[i-1] == t[j-1]): dp[i][j] = dp[i-1][j-1]+dp[i-1][j] else: dp[i][j] = dp[i-1][j] 不同点 : 不是判断是否为子序列(不求最大值)，也不是求最长公共子序列(不求严格顺序最大值), 而是求有几个，所以需要当相等时，用当前dp+之前dp,不等时，相当于最大值为之前的dp。\n初始化: 根据递推公式可得，此时要对根据dp的定义数组进行初始化(dp[i][0],dp[0][j])。\ndp[i][0]: 以i-1为结尾的s可以随便删除元素，出现空字符串的个数。:当i=1，应该有一个空字符串，所以应都初始化为1 dp[0][j]: 空字符串s可以随便删除元素，出现以j-1为结尾的字符串t的个数,0 dp[0][0]：应该是1，空字符串s，可以删除0个元素，变成空字符串t。 【两个字符串的删除操作】 给定两个单词 word1 和 word2 ，返回使得 word1 和 word2 相同所需的最小步数。\n每步 可以删除任意一个字符串中的一个字符。\n示例 1：\n输入: word1 = \u0026ldquo;sea\u0026rdquo;, word2 = \u0026ldquo;eat\u0026rdquo; 输出: 2 解释: 第一步将 \u0026ldquo;sea\u0026rdquo; 变为 \u0026ldquo;ea\u0026rdquo; ，第二步将 \u0026ldquo;eat \u0026ldquo;变为 \u0026ldquo;ea\u0026rdquo;\ndp数组的定义： 以i-1为结尾的word1 和 j-1为结尾的word2 ， 想要达到相等，需要删除元素的最小次数\n递推公式 ： 分为此时 i-1 == j-1 , i-1 != j-1 两种。如果相等，说明不需要删除，保持上一次的操作次数，如果不相等，就有 ： 删除word1中的字符，删除word2中的字符，同时删除两个中的字符三种情况，在这三种情况中取最小值。\nif(sword1[i-1] == word2[j-1]): dp[i][j] = dp[i-1][j-1] else: dp[i][j] = math.max(dp[i-1][j] + 1, math.max(dp[i][j-1] + 1, dp[i-1][j-1] + 2)) 【编辑距离】 给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数。\n你可以对一个单词进行如下三种操作：\n插入一个字符\n删除一个字符\n替换一个字符\n示例 1：\n输入：word1 = \u0026ldquo;horse\u0026rdquo;, word2 = \u0026ldquo;ros\u0026rdquo;\n输出：3\ndp数组的定义 ： 和上一道一样 需要注意的是，如何通过dp数组实现这三种操作？ 对于插入/删除 ： 其实删除一个word1中的字符和word2中插入一个字符操作一样 例如 word1 = \u0026ldquo;ad\u0026rdquo; ，word2 = \u0026ldquo;a\u0026rdquo;，word1删除元素\u0026rsquo;d\u0026rsquo; 和 word2添加一个元素\u0026rsquo;d\u0026rsquo;，变成word1=\u0026ldquo;a\u0026rdquo;, word2=\u0026ldquo;ad\u0026rdquo;， 最终的操作数是一样 对于替换操作 ： 相当于在之前的dp[i-1][j-1]的基础上+1 递推公式: if(word1.charAt(i-1) == word2.charAt(j-1)) { dp[i][j] = dp[i-1][j-1]; //如果相同，不操作 }else { //如果不相同，在word1，word2，两个字符都删除的操作中选择操作数最小的 dp[i][j] = Math.min(dp[i-1][j] + 1, Math.min(dp[i][j-1] + 1, dp[i-1][j-1]+2)); } 【回文子串】 给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。\n具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。\n示例 1：\n输入：\u0026ldquo;abc\u0026rdquo; 输出：3 解释：三个回文子串: \u0026ldquo;a\u0026rdquo;, \u0026ldquo;b\u0026rdquo;, \u0026ldquo;c\u0026rdquo;\ndp数组的定义 ： 和之前求什么定义什么不同，此时要从回文串的性质来推导 ： 左边字符记作i,右边字符记作j,两字符相同时，此时有三种情况： 1.i,j指向同一个字符 ： 此时是回文子串 2.i,j相隔一个字符: 此时也是回文子串 3.i,j之间的距离 \u0026gt; 1 : 那么就要看 i-1, j-1对应区间的子串是否为回文字符，如果是，那么此时也是回文子串 dp[i][j]：表示区间范围[i,j] （注意是左闭右闭）的子串是否是回文子串，如果是dp[i][j]为true，否则为false。 if(s.charAt(i) == s.charAt(j)) { if(j - i \u0026lt;= 1) { dp[i][j] = true; result++; }else { if(dp[i+1][j-1] == true) { dp[i][j] = true; result++; } } } 遍历顺序 ： 根据递推公式确定，因为当前dp[i][j]是由dp[i+1][j-1]推导得出的，也就是由左下方推导出的，所以遍历顺序应当从下到上，从左到右进行遍历\n初始化：默认都为false，避免出错\n【最长回文子序列】 给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。\n子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。\n示例 1：\n输入：s = \u0026ldquo;bbbab\u0026rdquo; 输出：4 解释：一个可能的最长回文子序列为 \u0026ldquo;bbbb\u0026rdquo; 。\n和上一题【回文子串】类似，不过由求回文子串变成了求回文子序列，两者最大的区别是子串要求连续，子序列不要求连续\ndp[i][j]： i~j之间范围内最长的回文子序列\n递推公式：\n此时，如果i,j相同，那么就相当于在之前的回文子序列范围上+2个字符作为最长回文子序列\n如果i,j不相同，那么就从只取i,或者只取j的情况下选出最大值作为此时的最长子序列\n//如果i 和 j相等，从原来的最长子序列上加两个字符 if(s.charAt(i) == s.charAt(j)) { dp[i][j] = dp[i+1][j-1] + 2; }else { //如果不相等，就从取i，取j，两个字符串里取最大值 dp[i][j] = Math.max(dp[i][j-1], dp[i+1][j]); } 遍历顺序 ： 根据递推公式，可以知道还是从左下，左，下，三个方向递推当前结果，所以要从下往上，从左往右进行初始化\n数组初始化：如果此时i == j,说明此时是回文子序列，长度为1。\n//初始化当i = j时的情况为1（一个字符） for(int i = 0 ; i \u0026lt; s.length() ; i++) { dp[i][i] = 1; } 返回的结果 ： 根据dp的定义，应当返回:dp[0][s.length()-1],范围最大时的回文子串。 ","date": "2025-06-14T00:00:00+00:00",
      "updated": "2025-06-15T14:38:58+08:00"
    }, 
    {
      "objectID": "08d916ce800c13a660e205c615063679-en",
      "lang": "en",
      "permalink": "https://wittleLuna.github.io/en/post/dfsbfs%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/",
      "title": "theoretical basis of DFS/BFS","content": " 深度优先搜索理论基础 两者大概的区别： dfs是朝一个方向去搜，不到黄河不回头，直到遇到绝境了，搜不下去了，再换方向（换方向的过程就涉及到了回溯）。\nbfs是先把本节点所连接的所有节点遍历一遍，走到下一个节点的时候，再把连接节点的所有节点遍历一遍，搜索方向更像是广度，四面八方的搜索过程。\ndfs搜索过程 如图一，是一个无向图，我们要搜索从节点1到节点6的所有路径。 那么dfs搜索的第一条路径是这样的： （假设第一次延默认方向，就找到了节点6），图二 此时我们找到了节点6，（遇到黄河了，是不是应该回头了），那么应该再去搜索其他方向了。 如图三： 路径2撤销了，改变了方向，走路径3（红色线）， 接着也找到终点6。 那么撤销路径2，改为路径3，在dfs中其实就是回溯的过程（这一点很重要，很多录友不理解dfs代码中回溯是用来干什么的）\n又找到了一条从节点1到节点6的路径，又到黄河了，此时再回头，下图图四中，路径4撤销（回溯的过程），改为路径5。 又找到了一条从节点1到节点6的路径，又到黄河了，此时再回头，下图图五，路径6撤销（回溯的过程），改为路径7，路径8 和 路径7，路径9， 结果发现死路一条，都走到了自己走过的节点。 那么节点2所连接路径和节点3所链接的路径 都走过了，撤销路径只能向上回退，去选择撤销当初节点4的选择，也就是撤销路径5，改为路径10 。 如图图六： 上图演示中，其实我并没有把 所有的 从节点1 到节点6的dfs（深度优先搜索）的过程都画出来，那样太冗余了，但 已经把dfs 关键的地方都涉及到了，关键就两点：\n搜索方向，是认准一个方向搜，直到碰壁之后再换方向 换方向是撤销原路径，改为节点链接的下一个路径，回溯的过程。 代码框架 二叉树的递归法其实就是dfs，而二叉树的迭代法，就是bfs（广度优先搜索）\n所以dfs，bfs其实是基础搜索算法，也广泛应用与其他数据结构与算法中。\n回溯法代码框架:\nvoid backtracking(参数) { if (终止条件) { 存放结果; return; } for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) { 处理节点; backtracking(路径，选择列表); // 递归 回溯，撤销处理结果 } } 回溯算法，其实就是dfs的过程\ndfs算法框架:\nvoid dfs(参数) { if (终止条件) { 存放结果; return; } for (选择：本节点所连接的其他节点) { 处理节点; dfs(图，选择的节点); // 递归 回溯，撤销处理结果 } } 深搜三部曲 1.确认递归函数，参数\n一般情况，深搜需要 二维数组数组结构保存所有路径，需要一维数组保存单一路径，这种保存结果的数组，我们可以定义一个全局变量，避免让我们的函数参数过多。\n如:\nArrayList\u0026lt;ArrayList\u0026lt;int\u0026gt;\u0026gt; result; // 保存符合条件的所有路径 ArrayList\u0026lt;int\u0026gt; path; // 起点到终点的路径 void dfs (图，目前搜索的节点) 2.确认终止条件\nif (终止条件) { 存放结果; return; } 终止添加不仅是结束本层递归，同时也是我们收获结果的时候。\n3.处理目前搜索节点出发的路径\nfor (选择：本节点所连接的其他节点) { 处理节点; dfs(图，选择的节点); // 递归 回溯，撤销处理结果 } 广度优先搜索理论基础 广搜的应用场景 广搜的搜索方式就适合于解决两个点之间的最短路径问题。\n因为广搜是从起点出发，以起始点为中心一圈一圈进行搜索，一旦遇到终点，记录之前走过的节点就是一条最短路。\n当然，也有一些问题是广搜 和 深搜都可以解决的，例如岛屿问题，这类问题的特征就是不涉及具体的遍历方式，只要能把相邻且相同属性的节点标记上就行。\n广搜的过程 我们用一个方格地图，假如每次搜索的方向为 上下左右（不包含斜上方），那么给出一个start起始位置，那么BFS就是从四个方向走出第一步。 如果加上一个end终止位置，那么使用BFS的搜索过程如图所示： 我们从图中可以看出，从start起点开始，是一圈一圈，向外搜索，方格编号1为第一步遍历的节点，方格编号2为第二步遍历的节点，第四步的时候我们找到终止点end。\n正是因为BFS一圈一圈的遍历方式，所以一旦遇到终止点，那么一定是一条最短路径。\n而且地图还可以有障碍，如图所示: 从图中可以看出，如果添加了障碍，我们是第六步才能走到end终点。\n只要BFS只要搜到终点一定是一条最短路径\n代码框架 需要一个容器，能保存我们要遍历过的元素就可以，那么用队列，还是用栈，甚至用数组，都是可以的。\n用队列的话，就是保证每一圈都是一个方向去转，例如统一顺时针或者逆时针。\n因为队列是先进先出，加入元素和弹出元素的顺序是没有改变的。\n如果用栈的话，就是第一圈顺时针遍历，第二圈逆时针遍历，第三圈有顺时针遍历。\n因为栈是先进后出，加入元素和弹出元素的顺序改变了。\n那么广搜需要注意 转圈搜索的顺序吗？ 不需要！\n// 表示四个方向：右、下、左、上 private static final int[][] dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; // grid 是地图，visited 用来标记访问过的节点 public static void bfs(char[][] grid, boolean[][] visited, int x, int y) { Queue\u0026lt;int[]\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); // 定义队列 queue.offer(new int[]{x, y}); // 起始节点加入队列 visited[x][y] = true; // 只要加入队列，立刻标记为访问过的节点 while (!queue.isEmpty()) { // 开始遍历队列里的元素 int[] cur = queue.poll(); // 从队列取出元素 int curx = cur[0]; int cury = cur[1]; // 当前节点坐标 // 开始想当前节点的四个方向（右、下、左、上）去遍历 for (int i = 0; i \u0026lt; 4; i++) { int nextx = curx + dir[i][0]; int nexty = cury + dir[i][1]; // 获取周边四个方向的坐标 // 坐标越界了，直接跳过 if (nextx \u0026lt; 0 || nextx \u0026gt;= grid.length || nexty \u0026lt; 0 || nexty \u0026gt;= grid[0].length) { continue; } // 如果节点没被访问过 if (!visited[nextx][nexty]) { queue.offer(new int[]{nextx, nexty}); // 队列添加该节点为下一轮要遍历的节点 visited[nextx][nexty] = true; // 只要加入队列立刻标记，避免重复访问 } } } } ","date": "2025-06-14T00:00:00+00:00",
      "updated": "2025-06-15T14:37:49+08:00"
    }, 
    {
      "objectID": "c7cd35aad8111e2ecee01efdd394514b-en",
      "lang": "en",
      "permalink": "https://wittleLuna.github.io/en/post/%E5%9B%BE%E8%AE%BA%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/",
      "title": "theoretical basis of Graph Theory","content": " 图论 图论理论基础 图的基本概念 二维坐标中，两点可以连成线，多个点连成的线就构成了图。\n当然图也可以就一个节点，甚至没有节点（空图）\n图的种类 整体上分为有向图和无向图\n有向图：图中边是有方向的： 无向图：图中边没有方向: 加权有向图，就是图中边是有权值的: 加权无向图也是同理\n度 无向图:有几条边连接该节点，该节点就有几度 例如，该无向图中，节点4的度为5，节点6的度为3。 有向图:每个节点有出度和入度 出度：从该节点出发的边的个数 入度:指向该节点的边的个数\n例如，该有向图中，节点3的入度为2，出度为1，节点1的入度为0，出度为2。 连通性 在图中表示节点的连通情况，称之为连通性\n连通图 在无向图中，任何两个节点都是可以到达的，我们称之为连通图 如果有节点不能到达其他节点，则为非连通图 强连通图 在有向图中，任何两个节点是可以相互到达的，我们称之为 强连通图。、\n注意：强连通图是在有向图中任何两个节点是可以相互到达\n这个图不是强连通图，因为1能到5的位置，但是5不能到1的位置。\n这个图是强连通图\n连通分量 在无向图中的极大连通子图称之为该图的一个连通分量。 该无向图中节点1、节点2、节点5构成的子图就是 该无向图中的一个连通分量，该子图所有节点都是相互可达到的。\n同理，节点3、节点4、节点6构成的子图 也是该无向图中的一个连通分量。\n那么无向图中节点3 、节点4构成的子图 是该无向图的联通分量吗？\n不是！\n因为必须是极大联通子图才能是连通分量，所以 必须是节点3、节点4、节点6构成的子图才是连通分量。\n在图论中，连通分量是一个很重要的概念，例如岛屿问题（后面章节会有专门讲解）其实就是求连通分量。\n强连通分量 在有向图中极大强连通子图称之为该图的强连通分量。 节点1、节点2、节点3、节点4、节点5 构成的子图是强连通分量，因为这是强连通图，也是极大图。\n节点6、节点7、节点8构成的子图 不是强连通分量，因为这不是强连通图，节点8 不能达到节点6。\n节点1、节点2、节点5 构成的子图 也不是 强连通分量，因为这不是极大图。\n图的构造 一般使用邻接表、邻接矩阵 或者用类来表示。\n主要是 朴素存储、邻接表和邻接矩阵。\n邻接矩阵 邻接矩阵 使用 二维数组来表示图结构。 邻接矩阵是从节点的角度来表示图，有多少节点就申请多大的二维数组。\n例如： grid[2][5] = 6，表示 节点 2 连接 节点5 为有向图，节点2 指向 节点5，边的权值为6。\n如果想表示无向图，即：grid[2][5] = 6，grid[5][2] = 6，表示节点2 与 节点5 相互连通，权值为6。\n在一个 n （节点数）为8 的图中，就需要申请 8 * 8 这么大的空间。\n图中有一条双向边，即：grid[2][5] = 6，grid[5][2] = 6\n这种表达方式（邻接矩阵） 在 边少，节点多的情况下，会导致申请过大的二维数组，造成空间浪费。\n而且在寻找节点连接情况的时候，需要遍历整个矩阵，即 n * n 的时间复杂度，同样造成时间浪费。\n邻接矩阵的优点：\n表达方式简单，易于理解 检查任意两个顶点间是否存在边的操作非常快 适合稠密图，在边数接近顶点数平方的图中，邻接矩阵是一种空间效率较高的表示方法。 缺点：\n遇到稀疏图，会导致申请过大的二维数组造成空间浪费 且遍历 边 的时候需要遍历整个n * n矩阵，造成时间浪费 邻接表 邻接表 使用 数组 + 链表的方式来表示。 邻接表是从边的数量来表示图，有多少边 才会申请对应大小的链表。\n这里表达的图是：\n节点1 指向 节点3 和 节点5 节点2 指向 节点4、节点3、节点5 节点3 指向 节点4 节点4指向节点1 有多少边 邻接表才会申请多少个对应的链表节点。 从图中可以直观看出 使用 数组 + 链表 来表达 边的连接情况 。\n邻接表的优点：\n对于稀疏图的存储，只需要存储边，空间利用率高 遍历节点连接情况相对容易\n缺点：\n检查任意两个节点间是否存在边，效率相对低，需要 O(V)时间，V表示某节点连接其他节点的数量。 实现相对复杂，不易理解 以上大家可能理解比较模糊，没关系，因为大家还没做过图论的题目，对于图的表达没有概念。\n这里我先不给出具体的实现代码，大家先有个初步印象，在后面算法题实战中，我还会讲到具体代码实现，等带大家做算法题，写了代码之后，自然就理解了。\n图的遍历方式 图的遍历方式基本是两大类：\n深度优先搜索（dfs） 广度优先搜索（bfs）\n二叉树的递归遍历，是dfs 在二叉树上的遍历方式。\n二叉树的层序遍历，是bfs 在二叉树上的遍历方式。\ndfs 和 bfs 一种搜索算法，可以在不同的数据结构上进行搜索，在二叉树章节里是在二叉树这样的数据结构上搜索。\n而在图论章节，则是在图（邻接表或邻接矩阵）上进行搜索。\n","date": "2025-06-14T00:00:00+00:00",
      "updated": "2025-06-15T14:39:22+08:00"
    }, 
    {
      "objectID": "af8d9e6ebb52f38a177f234d18a71818-en",
      "lang": "en",
      "permalink": "https://wittleLuna.github.io/en/post/dijkstra%E7%AE%97%E6%B3%95/",
      "title": "Djikstra","content": "dijkstra 三部曲：\n第一步，选源点到哪个节点近且该节点未被访问过 第二步，该最近节点被标记访问过 第三步，更新非访问节点到源点的距离（即更新minDist数组）\n==解决单源最短路径问题，适用于有向图和无向图，但边权值不能为负==\n参加科学大会 解题思路 使用dijkstra模板实现\n代码实现\npublic static void main(String[] args){ Scanner sc = new Scanner(System.in); int pointsNum = sc.nextInt(); int edgesNum = sc.nextInt(); int[][] map = new int[pointsNum + 1][pointsNum + 1];\tboolean[] isTree = new boolean[pointsNum+1]; int[] minDis = new int[pointsNum + 1]; Arrays.fill(minDis, Integer.MAX_VALUE); minDis[1] = 0; for(int i = 0 ; i \u0026lt; edgesNum; i++) { int p1 = sc.nextInt(); int p2 = sc.nextInt(); int v = sc.nextInt(); map[p1][p2] = v; } for(int i = 1; i \u0026lt;= pointsNum; i ++) { int cur = 1; int min = Integer.MAX_VALUE; //第一步，选距离源点最近且未访问过的节点 for(int j = 1; j \u0026lt;= pointsNum; j++) { if(!isTree[j] \u0026amp;\u0026amp; minDis[j] \u0026lt; min) { min = minDis[j]; cur = j; } } //第二步，标记该节点为已经访问 isTree[cur] = true; //第三步，更新minDis， 非访问节点到源点的距离 for(int j = 1; j \u0026lt;= pointsNum; j++) { if(!isTree[j] \u0026amp;\u0026amp; map[cur][j] != 0 \u0026amp;\u0026amp; minDis[cur] + map[cur][j] \u0026lt; minDis[j]) { minDis[j] = minDis[cur] + map[cur][j]; //minDis[cur] + map[cur][j] 当前节点到源点的距离 + 当前节点到该非访问节点的距离 } } } if(minDis[pointsNum] == Integer.MAX_VALUE) { System.out.println(-1); }else { System.out.println(minDis[pointsNum]); } } 堆优化版本 import java.util.*; class Edge { int to; // 邻接顶点 int val; // 边的权重 Edge(int to, int val) { this.to = to; this.val = val; } } class MyComparison implements Comparator\u0026lt;Pair\u0026lt;Integer, Integer\u0026gt;\u0026gt; { @Override public int compare(Pair\u0026lt;Integer, Integer\u0026gt; lhs, Pair\u0026lt;Integer, Integer\u0026gt; rhs) { return Integer.compare(lhs.second, rhs.second); } } class Pair\u0026lt;U, V\u0026gt; { public final U first; public final V second; public Pair(U first, V second) { this.first = first; this.second = second; } } public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); int m = scanner.nextInt(); List\u0026lt;List\u0026lt;Edge\u0026gt;\u0026gt; grid = new ArrayList\u0026lt;\u0026gt;(n + 1); for (int i = 0; i \u0026lt;= n; i++) { grid.add(new ArrayList\u0026lt;\u0026gt;()); } for (int i = 0; i \u0026lt; m; i++) { int p1 = scanner.nextInt(); int p2 = scanner.nextInt(); int val = scanner.nextInt(); grid.get(p1).add(new Edge(p2, val)); } int start = 1; // 起点 int end = n; // 终点 // 存储从源点到每个节点的最短距离 int[] minDist = new int[n + 1]; Arrays.fill(minDist, Integer.MAX_VALUE); // 记录顶点是否被访问过 boolean[] visited = new boolean[n + 1]; // 优先队列中存放 Pair\u0026lt;节点，源点到该节点的权值\u0026gt; PriorityQueue\u0026lt;Pair\u0026lt;Integer, Integer\u0026gt;\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;(new MyComparison()); // 初始化队列，源点到源点的距离为0，所以初始为0 pq.add(new Pair\u0026lt;\u0026gt;(start, 0)); minDist[start] = 0; // 起始点到自身的距离为0 while (!pq.isEmpty()) { // 1. 第一步，选源点到哪个节点近且该节点未被访问过（通过优先级队列来实现） // \u0026lt;节点， 源点到该节点的距离\u0026gt; Pair\u0026lt;Integer, Integer\u0026gt; cur = pq.poll(); if (visited[cur.first]) continue; // 2. 第二步，该最近节点被标记访问过 visited[cur.first] = true; // 3. 第三步，更新非访问节点到源点的距离（即更新minDist数组） for (Edge edge : grid.get(cur.first)) { // 遍历 cur指向的节点，cur指向的节点为 edge // cur指向的节点edge.to，这条边的权值为 edge.val if (!visited[edge.to] \u0026amp;\u0026amp; minDist[cur.first] + edge.val \u0026lt; minDist[edge.to]) { // 更新minDist minDist[edge.to] = minDist[cur.first] + edge.val; pq.add(new Pair\u0026lt;\u0026gt;(edge.to, minDist[edge.to])); } } } if (minDist[end] == Integer.MAX_VALUE) { System.out.println(-1); // 不能到达终点 } else { System.out.println(minDist[end]); // 到达终点最短路径 } } } ","date": "2025-06-12T00:00:00+00:00",
      "updated": "2025-06-15T14:38:05+08:00"
    }, 
    {
      "objectID": "f7c17377324c8c2ad02f6bbdad9713d9-en",
      "lang": "en",
      "permalink": "https://wittleLuna.github.io/en/post/%E5%9B%BE%E8%AE%BA%E9%A2%98/",
      "title": "Graph questions","content": " 图的存储 邻接矩阵 Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); //n是节点数 int m = scanner.nextInt(); //m是边数 // 节点编号从1到n，所以申请 n+1 这么大的数组 int[][] graph = new int[n + 1][n + 1]; for (int i = 0; i \u0026amp;lt; m; i++) { int s = scanner.nextInt(); int t = scanner.nextInt(); // 使用邻接矩阵表示无向图，1 表示 s 与 t 是相连的 graph[s][t] = 1; } 邻接表 Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); //n是节点数 int m = scanner.nextInt(); //m是边数 // 节点编号从1到n，所以申请 n+1 这么大的数组 List\u0026amp;lt;LinkedList\u0026amp;lt;Integer\u0026amp;gt;\u0026amp;gt; graph = new ArrayList\u0026amp;lt;\u0026amp;gt;(n + 1); for (int i = 0; i \u0026amp;lt;= n; i++) { graph.add(new LinkedList\u0026amp;lt;\u0026amp;gt;()); } while (m-- \u0026amp;gt; 0) { int s = scanner.nextInt(); int t = scanner.nextInt(); // 使用邻接表表示 s -\u0026amp;gt; t 是相连的 graph.get(s).add(t); } 所有可达路径 题目描述 给定一个有 n 个节点的有向无环图，节点编号从 1 到 n。请编写一个函数，找出并返回所有从 …","date": "2025-06-12T00:00:00+00:00",
      "updated": "2025-06-15T14:39:32+08:00"
    }, 
    {
      "objectID": "553990afda82dc3f3fca468252c0adb1-en",
      "lang": "en",
      "permalink": "https://wittleLuna.github.io/en/post/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95prim-kruskal/",
      "title": "Minimum Spanning Tree","content": "最小生成树是所有节点的最小连通子图，即：以最小的成本（边的权值）将图中所有节点链接到一起。\nprim算法 图中有n个节点，那么一定可以用n-1条边将所有节点连接到一起。\n==只适用于加权无向图==\n那么如何选择这n-1条边就是最小生成树算法的任务所在。\n在这个图中，如何选取n-1条边使得图中所有节点连接到一起，并且边的权值和最小呢？\n（图中为n为7，即7个节点，那么只需要n-1即6条边就可以讲所有顶点连接到一起）\nprim算法是从节点的角度采用贪心的策略每次寻找距离最小生成树最近的节点并加入到最小生成树中。\nprim算法核心就是三步，我称为prim三部曲，大家一定要熟悉这三步，代码相对会好些很多：\n第一步，选距离生成树最近节点 第二步，最近节点加入生成树 第三步，更新非生成树节点到生成树的距离（即更新minDist数组） minDist数组的含义：记录每一个节点距离最小生成树的最近距离。\n最小生成树prim算法\n寻宝 在世界的某个区域，有一些分散的神秘岛屿，每个岛屿上都有一种珍稀的资源或者宝藏。国王打算在这些岛屿上建公路，方便运输。\n不同岛屿之间，路途距离不同，国王希望你可以规划建公路的方案，如何可以以最短的总公路距离将 所有岛屿联通起来（注意：这是一个无向图）。\n给定一张地图，其中包括了所有的岛屿，以及它们之间的距离。以最小化公路建设长度，确保可以链接到所有岛屿。\n输入描述 第一行包含两个整数V 和 E，V代表顶点数，E代表边数 。顶点编号是从1到V。例如：V=2，一个有两个顶点，分别是1和2。\n接下来共有 E 行，每行三个整数 v1，v2 和 val，v1 和 v2 为边的起点和终点，val代表边的权值。\n输出描述 输出联通所有岛屿的最小路径总距离 输入示例 7 11 1 2 1 1 3 1 1 5 2 2 6 1 2 4 2 2 3 2 3 4 1 4 5 1 5 6 2 5 7 1 6 7 1 输出示例 6 提示信息 数据范围： 2 \u0026lt;= V \u0026lt;= 10000; 1 \u0026lt;= E \u0026lt;= 100000; 0 \u0026lt;= val \u0026lt;= 10000;\n如下图，可见将所有的顶点都访问一遍，总距离最低是6. 解题思路 最小生成树的模板题，这里使用prim算法解决\n代码实现 public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int v = scanner.nextInt(); int e = scanner.nextInt(); int x,y,val; //记录图的邻接矩阵 int[][] grid = new int[v+1][v+1]; while(e -- \u0026gt; 0) { x = scanner.nextInt(); y = scanner.nextInt(); val = scanner.nextInt(); grid[x][y] = val; grid[y][x] = val; } //minDist数组 int[] mindist = new int[v+1]; Arrays.fill(mindist, 10001);//初始化 //记录节点是否在最小生成树里 boolean[] isTree = new boolean[v+1]; mindist[1] = 0; for(int i = 1; i \u0026lt; v ; i++) { int cur = -1; int minVal = Integer.MAX_VALUE; //第一步 for(int j = 1; j \u0026lt;= v ; j++) { if(!isTree[j] \u0026amp;\u0026amp; mindist[j] \u0026lt; minVal) { minVal = mindist[j]; cur = j; } } //第二步 isTree[cur] = true; //第三步 for(int j = 1 ; j \u0026lt;= v; j++) { if(!isTree[j] \u0026amp;\u0026amp; grid[cur][j] \u0026lt; mindist[j]) { mindist[j] = grid[cur][j]; } } } int result = 0; for(int i = 2 ; i \u0026lt;= v; i++) { result += mindist[i]; } System.out.println(result); }\tkruskal算法 kruskal的思路：\n边的权值排序，因为要优先选最小的边加入到生成树里 遍历排序后的边 如果边首尾的两个节点在同一个集合，说明如果连上这条边图中会出现环 如果边首尾的两个节点不在同一个集合，加入到最小生成树，并把两个节点加入同一个集合 kruskal算法\n寻宝 和上题同题\n代码实现 public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int v = scanner.nextInt(); int e = scanner.nextInt(); int result = 0; DisjointSet ds = new DisjointSet(v); //使用并查集实现查看节点是否在同一集合 ds.init(); //存储节点和边权值的结构 List\u0026lt;Edge\u0026gt; edgeList = new ArrayList\u0026lt;Edge\u0026gt;(); for(int i = 0 ; i \u0026lt; e ; i++) { int l = scanner.nextInt(); int r = scanner.nextInt(); int val = scanner.nextInt(); edgeList.add(new Edge(l, r, val)); } // 执行对边权值的排序 edgeList.sort(Comparator.comparingInt(edge -\u0026gt; edge.val)); for(Edge edge : edgeList) { //如果节点不在同一集合 if(!ds.isSame(edge.l, edge.r)) { //结果加入当前权值 result += edge.val; //节点加入集合 ds.join(edge.l, edge.r); } } System.out.println(result); }\t}\tclass DisjointSet{ int n; int[] father; public DisjointSet(int n) { this.n = n; this.father = new int[n+1]; } public void init() { for(int i = 1 ;i \u0026lt; father.length; i++) { father[i] = i; } } public void join(int u, int v) { u = find(u); v = find(v); if(u == v)return; father[v] = u; } public int find(int u) { return (u == father[u])? u: (father[u] = find(father[u])); } public boolean isSame(int u, int v) { u = find(u); v = find(v); return u == v; } //找到需要删除的那条边 public void getRemovedEdge(ArrayList\u0026lt;int[]\u0026gt; edge) { init();//注意每次都要初始化并查集 for(int i = 0 ; i \u0026lt; edge.size() ; i++) {//遍历所有边 if(isSame(edge.get(i)[0], edge.get(i)[1])) {//并查集里有，说明这条边就是要删除的边 System.out.println(edge.get(i)[0]+\u0026#34; \u0026#34;+edge.get(i)[1]); return; }else { join(edge.get(i)[0], edge.get(i)[1]); } } } public boolean isTreeAfterRemoveEdge(ArrayList\u0026lt;int[]\u0026gt; edge, int deleteEdge) { init();//注意每次都要初始化并查集 for(int i = 0 ; i \u0026lt; n; i++) { if(i == deleteEdge)continue; if(isSame(edge.get(i)[0], edge.get(i)[1])) { //说明此时构成了环，不删deleteEdge而是删后一条 return false; } join(edge.get(i)[0], edge.get(i)[1]); } return true; } } class Edge{ int l,r,val; public Edge(int l, int r, int val) { this.l = l; this.r = r; this.val = val; } } 拓展1 题目要求将最小生成树的边输出的话，应该怎么办呢？\nKruskal 算法 输出边的话，相对prim 要容易很多，因为 Kruskal 本来就是直接操作边，边的结构自然清晰，不用像 prim一样 需要再将节点连成线输出边 （因为prim是对节点操作，而 Kruskal是对边操作，这是本质区别）\n当判断两个节点不在同一个集合的时候，这两个节点的边就加入到最小生成树\n拓展2 什么情况用哪个算法更合适呢。\nKruskal 与 prim 的关键区别在于，prim维护的是节点的集合，而 Kruskal 维护的是边的集合。 如果 一个图中，节点多，但边相对较少，那么使用Kruskal 更优。\n在节点数量固定的情况下，图中的边越少，Kruskal 需要遍历的边也就越少。\n而prim 算法是对节点进行操作的，节点数量越少，prim算法效率就越优。\n所以在 稀疏图中，用Kruskal更优。 在稠密图中，用prim算法更优。\n==边数量较少为稀疏图，接近或等于完全图（所有节点皆相连）为稠密图==\nPrim 算法 时间复杂度为O(n^2)，其中 n 为节点数量，它的运行效率和图中边树无关，适用稠密图。\nKruskal算法 时间复杂度 为 nlogn，其中n 为边的数量，适用稀疏图。\n","date": "2025-06-12T00:00:00+00:00",
      "updated": "2025-06-15T14:39:54+08:00"
    }, 
    {
      "objectID": "32e32753f52fbaf154fe153782b5c8be-en",
      "lang": "en",
      "permalink": "https://wittleLuna.github.io/en/post/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/",
      "title": "Backtracking-algorithm","content": "回溯和递归相辅相成，本质上是暴力查找算法(穷举)，所有的回溯法都可以抽象为树形结构\n回溯法，一般可以解决如下几种问题：\n组合问题：N个数里面按一定规则找出k个数的集合 切割问题：一个字符串按一定规则有几种切割方式 子集问题：一个N个数的集合里有多少符合条件的子集 排列问题：N个数按一定规则全排列，有几种排列方式 棋盘问题：N皇后，解数独等等 模板框架:\nvoid backtracking(参数) { if (终止条件) { 存放结果; return; } for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) { 处理节点; backtracking(路径，选择列表); // 递归 回溯，撤销处理结果 } } 回溯三部曲: 1.确定递归函数的参数和返回值 2.确定递归的终止条件 3.确定单层搜索的逻辑\n一般返回值都为void\n组合问题 ==需要startIndex来保证元素不被重复选取==\n组合 给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。\n你可以按 任何顺序 返回答案。\n示例 1：\n输入：n = 4, k = 2 输出： [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4], ]\n确定参数和返回值： 参数：n:代表遍历的次数 k:代表需要走到的深度 startIndex: 代表当前层的遍历位置(因为是组合问题，每个节点只能从其之后的位置开始遍历)\n返回值：none, 使用全局遍历存储结果和当前路径的元素\n确定递归终止条件： 如果当前路径的元素=当前的深度 ： 说明找到的元素个数符合要求，那么把当前路径作为一种结果加入结果变量，之后返回 确定单层的递归逻辑： for循环，加入当前的元素，之后递归进行下一层循环，注意循环开始的位置，之后回溯去掉当前加入的元素（删除当前元素，之后回溯加入其他元素） …","date": "2025-06-11T00:00:00+00:00",
      "updated": "2025-06-15T14:39:09+08:00"
    }
]
