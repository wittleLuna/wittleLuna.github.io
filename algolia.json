[
  {
    "objectID": "1749686400",
    "permalink": "/post/dijkstra%E7%AE%97%E6%B3%95/",
    "title": "Djikstra算法","content": "dijkstra 三部曲：\n第一步，选源点到哪个节点近且该节点未被访问过 第二步，该最近节点被标记访问过 第三步，更新非访问节点到源点的距离（即更新minDist数组）\n==解决单源最短路径问题，适用于有向图和无向图，但边权值不能为负==\n参加科学大会 解题思路 使用dijkstra模板实现\n代码实现\npublic static void main(String[] args){ Scanner sc = new Scanner(System.in); int pointsNum = sc.nextInt(); int edgesNum = sc.nextInt(); int[][] map = new int[pointsNum + 1][pointsNum + 1];\tboolean[] isTree = new boolean[pointsNum+1]; int[] minDis = new int[pointsNum + 1]; Arrays.fill(minDis, Integer.MAX_VALUE); minDis[1] = 0; for(int i = 0 ; i \u0026lt; edgesNum; i++) { int p1 = sc.nextInt(); int p2 = sc.nextInt(); int v = sc.nextInt(); map[p1][p2] = v; } for(int i = 1; i \u0026lt;= pointsNum; i ++) { int cur = 1; int min = Integer.MAX_VALUE; //第一步，选距离源点最近且未访问过的节点 for(int j = 1; j \u0026lt;= pointsNum; j++) { if(!isTree[j] \u0026amp;\u0026amp; minDis[j] \u0026lt; min) { min = minDis[j]; cur = j; } } //第二步，标记该节点为已经访问 isTree[cur] = true; //第三步，更新minDis， 非访问节点到源点的距离 for(int j = 1; j \u0026lt;= pointsNum; j++) { if(!isTree[j] \u0026amp;\u0026amp; map[cur][j] != 0 \u0026amp;\u0026amp; minDis[cur] + map[cur][j] \u0026lt; minDis[j]) { minDis[j] = minDis[cur] + map[cur][j]; //minDis[cur] + map[cur][j] 当前节点到源点的距离 + 当前节点到该非访问节点的距离 } } } if(minDis[pointsNum] == Integer.MAX_VALUE) { System.out.println(-1); }else { System.out.println(minDis[pointsNum]); } } 堆优化版本 import java.util.*; class Edge { int to; // 邻接顶点 int val; // 边的权重 Edge(int to, int val) { this.to = to; this.val = val; } } class MyComparison implements Comparator\u0026lt;Pair\u0026lt;Integer, Integer\u0026gt;\u0026gt; { @Override public int compare(Pair\u0026lt;Integer, Integer\u0026gt; lhs, Pair\u0026lt;Integer, Integer\u0026gt; rhs) { return Integer.compare(lhs.second, rhs.second); } } class Pair\u0026lt;U, V\u0026gt; { public final U first; public final V second; public Pair(U first, V second) { this.first = first; this.second = second; } } public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); int m = scanner.nextInt(); List\u0026lt;List\u0026lt;Edge\u0026gt;\u0026gt; grid = new ArrayList\u0026lt;\u0026gt;(n + 1); for (int i = 0; i \u0026lt;= n; i++) { grid.add(new ArrayList\u0026lt;\u0026gt;()); } for (int i = 0; i \u0026lt; m; i++) { int p1 = scanner.nextInt(); int p2 = scanner.nextInt(); int val = scanner.nextInt(); grid.get(p1).add(new Edge(p2, val)); } int start = 1; // 起点 int end = n; // 终点 // 存储从源点到每个节点的最短距离 int[] minDist = new int[n + 1]; Arrays.fill(minDist, Integer.MAX_VALUE); // 记录顶点是否被访问过 boolean[] visited = new boolean[n + 1]; // 优先队列中存放 Pair\u0026lt;节点，源点到该节点的权值\u0026gt; PriorityQueue\u0026lt;Pair\u0026lt;Integer, Integer\u0026gt;\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;(new MyComparison()); // 初始化队列，源点到源点的距离为0，所以初始为0 pq.add(new Pair\u0026lt;\u0026gt;(start, 0)); minDist[start] = 0; // 起始点到自身的距离为0 while (!pq.isEmpty()) { // 1. 第一步，选源点到哪个节点近且该节点未被访问过（通过优先级队列来实现） // \u0026lt;节点， 源点到该节点的距离\u0026gt; Pair\u0026lt;Integer, Integer\u0026gt; cur = pq.poll(); if (visited[cur.first]) continue; // 2. 第二步，该最近节点被标记访问过 visited[cur.first] = true; // 3. 第三步，更新非访问节点到源点的距离（即更新minDist数组） for (Edge edge : grid.get(cur.first)) { // 遍历 cur指向的节点，cur指向的节点为 edge // cur指向的节点edge.to，这条边的权值为 edge.val if (!visited[edge.to] \u0026amp;\u0026amp; minDist[cur.first] + edge.val \u0026lt; minDist[edge.to]) { // 更新minDist minDist[edge.to] = minDist[cur.first] + edge.val; pq.add(new Pair\u0026lt;\u0026gt;(edge.to, minDist[edge.to])); } } } if (minDist[end] == Integer.MAX_VALUE) { System.out.println(-1); // 不能到达终点 } else { System.out.println(minDist[end]); // 到达终点最短路径 } } } ","date": "2025-06-12 00:00:00",
    "updated": "2025-06-12 00:00:00"
  }, 
  {
    "objectID": "1749686400",
    "permalink": "/post/%E5%9B%BE%E8%AE%BA%E9%A2%98/",
    "title": "图论算法题","content": " 图的存储 邻接矩阵 Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); //n是节点数 int m = scanner.nextInt(); //m是边数 // 节点编号从1到n，所以申请 n+1 这么大的数组 int[][] graph = new int[n + 1][n + 1]; for (int i = 0; i \u0026amp;lt; m; i++) { int s = scanner.nextInt(); int t = scanner.nextInt(); // 使用邻接矩阵表示无向图，1 表示 s 与 t 是相连的 graph[s][t] = 1; } 邻接表 Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); //n是节点数 int m = scanner.nextInt(); //m是边数 // 节点编号从1到n，所以申请 n+1 这么大的数组 List\u0026amp;lt;LinkedList\u0026amp;lt;Integer\u0026amp;gt;\u0026amp;gt; graph = new ArrayList\u0026amp;lt;\u0026amp;gt;(n + 1); for (int i = 0; i \u0026amp;lt;= n; i++) { graph.add(new LinkedList\u0026amp;lt;\u0026amp;gt;()); } while (m-- \u0026amp;gt; 0) { int s = scanner.nextInt(); int t = scanner.nextInt(); // 使用邻接表表示 s -\u0026amp;gt; t 是相连的 graph.get(s).add(t); } 所有可达路径 题目描述 给定一个有 n 个节点的有向无环图，节点编号从 1 到 n。请编写一个函数，找出并返回所有从节点 1 到节点 n 的路径。每条路径应以节点编号的列表形式表示。 输入描述 第一行包含两个整数 N，M，表示图中拥有 N 个节点，M 条边\n后续 M 行，每行包含两个整数 s 和 t，表示图中的 s 节点与 t 节点中有一条路径\n输出描述 输出所有的可达路径，路径中所有节点之间空格隔开，每条路径独占一行，存在多条路径，路径输出的顺序可任意。如果不存在任何一条路径，则输出 -1。\n注意输出的序列 …","date": "2025-06-12 00:00:00",
    "updated": "2025-06-12 00:00:00"
  }, 
  {
    "objectID": "1749686400",
    "permalink": "/post/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95prim-kruskal/",
    "title": "最小生成树算法","content": "最小生成树是所有节点的最小连通子图，即：以最小的成本（边的权值）将图中所有节点链接到一起。\nprim算法 图中有n个节点，那么一定可以用n-1条边将所有节点连接到一起。\n==只适用于加权无向图==\n那么如何选择这n-1条边就是最小生成树算法的任务所在。\n在这个图中，如何选取n-1条边使得图中所有节点连接到一起，并且边的权值和最小呢？\n（图中为n为7，即7个节点，那么只需要n-1即6条边就可以讲所有顶点连接到一起）\nprim算法是从节点的角度采用贪心的策略每次寻找距离最小生成树最近的节点并加入到最小生成树中。\nprim算法核心就是三步，我称为prim三部曲，大家一定要熟悉这三步，代码相对会好些很多：\n第一步，选距离生成树最近节点 第二步，最近节点加入生成树 第三步，更新非生成树节点到生成树的距离（即更新minDist数组） minDist数组的含义：记录每一个节点距离最小生成树的最近距离。\n最小生成树prim算法\n寻宝 在世界的某个区域，有一些分散的神秘岛屿，每个岛屿上都有一种珍稀的资源或者宝藏。国王打算在这些岛屿上建公路，方便运输。\n不同岛屿之间，路途距离不同，国王希望你可以规划建公路的方案，如何可以以最短的总公路距离将 所有岛屿联通起来（注意：这是一个无向图）。\n给定一张地图，其中包括了所有的岛屿，以及它们之间的距离。以最小化公路建设长度，确保可以链接到所有岛屿。\n输入描述 第一行包含两个整数V 和 E，V代表顶点数，E代表边数 。顶点编号是从1到V。例如：V=2，一个有两个顶点，分别是1和2。\n接下来共有 E 行，每行三个整数 v1，v2 和 val，v1 和 v2 为边的起点和终点，val代表边的权值。\n输出描述 输出联通所有岛屿的最小路径总距离 输入示例 7 11 1 2 1 1 3 1 1 5 2 2 6 1 2 4 2 2 3 2 3 4 1 4 5 1 5 6 2 5 7 1 6 7 1 输出示例 6 提示信息 数据范围： 2 \u0026amp;lt;= V \u0026amp;lt;= 10000; 1 \u0026amp;lt;= E \u0026amp;lt;= 100000; 0 \u0026amp;lt;= val \u0026amp;lt;= 10000;\n如下图，可见将所有的顶点都访问一遍，总距离最低是6. 解题思路 最小生成树的模板题，这里使用prim算法解决\n代码实现 public static void main(String[] …","date": "2025-06-12 00:00:00",
    "updated": "2025-06-12 00:00:00"
  }, 
  {
    "objectID": "1749600000",
    "permalink": "/post/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/",
    "title": "回溯算法","content": "回溯和递归相辅相成，本质上是暴力查找算法(穷举)，所有的回溯法都可以抽象为树形结构\n回溯法，一般可以解决如下几种问题：\n组合问题：N个数里面按一定规则找出k个数的集合 切割问题：一个字符串按一定规则有几种切割方式 子集问题：一个N个数的集合里有多少符合条件的子集 排列问题：N个数按一定规则全排列，有几种排列方式 棋盘问题：N皇后，解数独等等 模板框架:\nvoid backtracking(参数) { if (终止条件) { 存放结果; return; } for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) { 处理节点; backtracking(路径，选择列表); // 递归 回溯，撤销处理结果 } } 回溯三部曲: 1.确定递归函数的参数和返回值 2.确定递归的终止条件 3.确定单层搜索的逻辑\n一般返回值都为void\n组合问题 ==需要startIndex来保证元素不被重复选取==\n组合 给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。\n你可以按 任何顺序 返回答案。\n示例 1：\n输入：n = 4, k = 2 输出： [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4], ]\n确定参数和返回值： 参数：n:代表遍历的次数 k:代表需要走到的深度 startIndex: 代表当前层的遍历位置(因为是组合问题，每个节点只能从其之后的位置开始遍历)\n返回值：none, 使用全局遍历存储结果和当前路径的元素\n确定递归终止条件： 如果当前路径的元素=当前的深度 ： 说明找到的元素个数符合要求，那么把当前路径作为一种结果加入结果变量，之后返回 确定单层的递归逻辑： for循环，加入当前的元素，之后递归进行下一层循环，注意循环开始的位置，之后回溯去掉当前加入的元素（删除当前元素，之后回溯加入其他元素） 剪枝优化: 如果k 和 n 相等，如4,4 那么整个递归只有一种可能。但是当前的程序仍然会尝试每个分支，返回符合结果要求的路径。所以可以考虑进行剪枝优化 如何剪枝 ： 如果循环位置开始时的剩余元素不满足题目里，减去当前元素，k的个数，for循环就不进行\n具体for循环条件上实现:\n1.起始位置: i = startIndex 2.终止条件: i \u0026amp;lt;= n- (k - …","date": "2025-06-11 00:00:00",
    "updated": "2025-06-11 00:00:00"
  }]