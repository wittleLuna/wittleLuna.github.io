<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>算法 on wittleLuna的博客</title>
    <link>https://wittleLuna.github.io/zh-cn/categories/%E7%AE%97%E6%B3%95/</link>
    <description>Recent content from wittleLuna的博客</description>
    <generator>Hugo</generator>
    <language>zh-CN</language>
    
    <managingEditor>syaz23277@gmail.com (wittleLuna)</managingEditor>
    <webMaster>syaz23277@gmail.com (wittleLuna)</webMaster>
    
    <copyright>本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处！</copyright>
    
    <lastBuildDate>Tue, 09 Sep 2025 14:36:58 +0800</lastBuildDate>
    
    
    <atom:link href="https://wittleLuna.github.io/zh-cn/categories/%E7%AE%97%E6%B3%95/index.xml" rel="self" type="application/rss&#43;xml" />
    

    
    

    <item>
      <title>[算法]协同过滤系统</title>
      <link>https://wittleLuna.github.io/zh-cn/post/%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Tue, 09 Sep 2025 00:00:00 &#43;0000</pubDate>
      <author>syaz23277@gmail.com (wittleLuna)</author>
      <guid>https://wittleLuna.github.io/zh-cn/post/%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4%E7%B3%BB%E7%BB%9F/</guid>
      <description>
        <![CDATA[<h1>[算法]协同过滤系统</h1><p>作者：wittleLuna（syaz23277@gmail.com）</p>
        
          <p><strong>协同过滤系统</strong>（Collaborative Filtering, CF）是一种推荐系统方法，它不依赖物品的内容特征，而是<strong>利用用户和物品之间的交互数据（如评分、点击、购买记录）来发现相似性并进行推荐</strong>。</p>
        
        <hr><p>本文2025-09-09首发于<a href='https://wittleLuna.github.io/'>wittleLuna的博客</a>，最后修改于2025-09-09</p>]]>
      </description>
      
        <category>算法</category>
      
    </item>
    
    

    <item>
      <title>[算法]GATv2图注意力网络</title>
      <link>https://wittleLuna.github.io/zh-cn/post/gatv2%E5%9B%BE%E6%B3%A8%E6%84%8F%E5%8A%9B%E7%BD%91%E7%BB%9C/</link>
      <pubDate>Tue, 09 Sep 2025 00:00:00 &#43;0000</pubDate>
      <author>syaz23277@gmail.com (wittleLuna)</author>
      <guid>https://wittleLuna.github.io/zh-cn/post/gatv2%E5%9B%BE%E6%B3%A8%E6%84%8F%E5%8A%9B%E7%BD%91%E7%BB%9C/</guid>
      <description>
        <![CDATA[<h1>[算法]GATv2图注意力网络</h1><p>作者：wittleLuna（syaz23277@gmail.com）</p>
        
          <h2 id="1-背景gat-的问题">
<a class="header-anchor" href="#1-%e8%83%8c%e6%99%afgat-%e7%9a%84%e9%97%ae%e9%a2%98"></a>
1. 背景：GAT 的问题
</h2><p>GAT（Velickovic et al., ICLR 2018）通过 <strong>自注意力机制</strong> 在图结构上聚合邻居节点信息，每条边的权重由注意力函数计算：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">\alpha_{ij} = \text{softmax}_j \left( \text{LeakyReLU}(a^T [W h_i \, || \, W h_j]) \right)
</span></span></code></pre></div><p>其中 h_i 是节点特征，W 是线性变换，a 是可学习参数。
但 GAT 有一个限制：注意力权重的计算公式在 <strong>输入的线性变换</strong> 之后才进入非线性函数，因此注意力分布空间受到限制，不能区分一些对称情况。例如：</p>
        
        <hr><p>本文2025-09-09首发于<a href='https://wittleLuna.github.io/'>wittleLuna的博客</a>，最后修改于2025-09-09</p>]]>
      </description>
      
        <category>算法</category>
      
    </item>
    
    

    <item>
      <title>最小生成树算法</title>
      <link>https://wittleLuna.github.io/zh-cn/post/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95prim-kruskal/</link>
      <pubDate>Thu, 12 Jun 2025 00:00:00 &#43;0000</pubDate>
      <author>syaz23277@gmail.com (wittleLuna)</author>
      <guid>https://wittleLuna.github.io/zh-cn/post/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95prim-kruskal/</guid>
      <description>
        <![CDATA[<h1>最小生成树算法</h1><p>作者：wittleLuna（syaz23277@gmail.com）</p>
        
          <p><strong>最小生成树是所有节点的最小连通子图</strong>，<strong>即：以最小的成本（边的权值）将图中所有节点链接到一起。</strong></p>
<h2 id="prim算法">
<a class="header-anchor" href="#prim%e7%ae%97%e6%b3%95"></a>
prim算法
</h2><p>图中有n个节点，那么一定可以用n-1条边将所有节点连接到一起。</p>
        
        <hr><p>本文2025-06-12首发于<a href='https://wittleLuna.github.io/'>wittleLuna的博客</a>，最后修改于2025-06-15</p>]]>
      </description>
      
        <category>算法</category>
      
    </item>
    
    

    <item>
      <title>图论理论基础</title>
      <link>https://wittleLuna.github.io/zh-cn/post/%E5%9B%BE%E8%AE%BA%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Sat, 14 Jun 2025 00:00:00 &#43;0000</pubDate>
      <author>syaz23277@gmail.com (wittleLuna)</author>
      <guid>https://wittleLuna.github.io/zh-cn/post/%E5%9B%BE%E8%AE%BA%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/</guid>
      <description>
        <![CDATA[<h1>图论理论基础</h1><p>作者：wittleLuna（syaz23277@gmail.com）</p>
        
          <h1 id="图论">
<a class="header-anchor" href="#%e5%9b%be%e8%ae%ba"></a>
图论
</h1><h2 id="图论理论基础">
<a class="header-anchor" href="#%e5%9b%be%e8%ae%ba%e7%90%86%e8%ae%ba%e5%9f%ba%e7%a1%80"></a>
图论理论基础
</h2><h3 id="图的基本概念">
<a class="header-anchor" href="#%e5%9b%be%e7%9a%84%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5"></a>
图的基本概念
</h3><p>二维坐标中，两点可以连成线，多个点连成的线就构成了图。</p>
<p>当然图也可以就一个节点，甚至没有节点（空图）</p>
<h3 id="图的种类">
<a class="header-anchor" href="#%e5%9b%be%e7%9a%84%e7%a7%8d%e7%b1%bb"></a>
图的种类
</h3><p><strong>整体上分为有向图和无向图</strong></p>
        
        <hr><p>本文2025-06-14首发于<a href='https://wittleLuna.github.io/'>wittleLuna的博客</a>，最后修改于2025-06-15</p>]]>
      </description>
      
        <category>算法</category>
      
    </item>
    
    

    <item>
      <title>回溯算法</title>
      <link>https://wittleLuna.github.io/zh-cn/post/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</link>
      <pubDate>Wed, 11 Jun 2025 00:00:00 &#43;0000</pubDate>
      <author>syaz23277@gmail.com (wittleLuna)</author>
      <guid>https://wittleLuna.github.io/zh-cn/post/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</guid>
      <description>
        <![CDATA[<h1>回溯算法</h1><p>作者：wittleLuna（syaz23277@gmail.com）</p>
        
          <p>回溯和递归相辅相成，本质上是暴力查找算法(穷举)，所有的回溯法都可以抽象为树形结构</p>
<p>回溯法，一般可以解决如下几种问题：</p>
<ul>
<li>组合问题：N个数里面按一定规则找出k个数的集合</li>
<li>切割问题：一个字符串按一定规则有几种切割方式</li>
<li>子集问题：一个N个数的集合里有多少符合条件的子集</li>
<li>排列问题：N个数按一定规则全排列，有几种排列方式</li>
<li>棋盘问题：N皇后，解数独等等</li>
</ul>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210130173631174.png" alt="image"></p>
        
        <hr><p>本文2025-06-11首发于<a href='https://wittleLuna.github.io/'>wittleLuna的博客</a>，最后修改于2025-06-15</p>]]>
      </description>
      
        <category>算法</category>
      
    </item>
    
    

    <item>
      <title>动态规划算法</title>
      <link>https://wittleLuna.github.io/zh-cn/post/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</link>
      <pubDate>Sat, 14 Jun 2025 00:00:00 &#43;0000</pubDate>
      <author>syaz23277@gmail.com (wittleLuna)</author>
      <guid>https://wittleLuna.github.io/zh-cn/post/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</guid>
      <description>
        <![CDATA[<h1>动态规划算法</h1><p>作者：wittleLuna（syaz23277@gmail.com）</p>
        
          <h2 id="动规五部曲">
<a class="header-anchor" href="#%e5%8a%a8%e8%a7%84%e4%ba%94%e9%83%a8%e6%9b%b2"></a>
动规五部曲
</h2><ol>
<li>确定dp数组和下标的含义</li>
<li>写出递推公式</li>
<li>确定dp数组如何初始化</li>
<li>确定遍历顺序（方向）</li>
<li>打印，举例推导验证dp数组是否正确</li>
</ol>
<h2 id="背包问题">
<a class="header-anchor" href="#%e8%83%8c%e5%8c%85%e9%97%ae%e9%a2%98"></a>
背包问题
</h2><h2 id="01背包">
<a class="header-anchor" href="#01%e8%83%8c%e5%8c%85"></a>
01背包
</h2><ul>
<li>可使用二维背包，一维滚动背包</li>
</ul>
<h3 id="二维背包">
<a class="header-anchor" href="#%e4%ba%8c%e7%bb%b4%e8%83%8c%e5%8c%85"></a>
二维背包
</h3><h4 id="基本了解">
<a class="header-anchor" href="#%e5%9f%ba%e6%9c%ac%e4%ba%86%e8%a7%a3"></a>
基本了解
</h4><ul>
<li>
<p>基本递推公式 : <code>dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]]+value[i])</code></p>
        
        <hr><p>本文2025-06-14首发于<a href='https://wittleLuna.github.io/'>wittleLuna的博客</a>，最后修改于2025-06-15</p>]]>
      </description>
      
        <category>算法</category>
      
    </item>
    
    

    <item>
      <title>Djikstra算法</title>
      <link>https://wittleLuna.github.io/zh-cn/post/dijkstra%E7%AE%97%E6%B3%95/</link>
      <pubDate>Thu, 12 Jun 2025 00:00:00 &#43;0000</pubDate>
      <author>syaz23277@gmail.com (wittleLuna)</author>
      <guid>https://wittleLuna.github.io/zh-cn/post/dijkstra%E7%AE%97%E6%B3%95/</guid>
      <description>
        <![CDATA[<h1>Djikstra算法</h1><p>作者：wittleLuna（syaz23277@gmail.com）</p>
        
          <p>dijkstra 三部曲：</p>
<p>第一步，选源点到哪个节点近且该节点未被访问过
第二步，该最近节点被标记访问过
第三步，更新非访问节点到源点的距离（即更新minDist数组）</p>
        
        <hr><p>本文2025-06-12首发于<a href='https://wittleLuna.github.io/'>wittleLuna的博客</a>，最后修改于2025-06-15</p>]]>
      </description>
      
        <category>算法</category>
      
    </item>
    
    

    <item>
      <title>DFS/BFS理论基础</title>
      <link>https://wittleLuna.github.io/zh-cn/post/dfsbfs%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Sat, 14 Jun 2025 00:00:00 &#43;0000</pubDate>
      <author>syaz23277@gmail.com (wittleLuna)</author>
      <guid>https://wittleLuna.github.io/zh-cn/post/dfsbfs%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/</guid>
      <description>
        <![CDATA[<h1>DFS/BFS理论基础</h1><p>作者：wittleLuna（syaz23277@gmail.com）</p>
        
          <ul>
<li></li>
</ul>
<h1 id="深度优先搜索理论基础">
<a class="header-anchor" href="#%e6%b7%b1%e5%ba%a6%e4%bc%98%e5%85%88%e6%90%9c%e7%b4%a2%e7%90%86%e8%ae%ba%e5%9f%ba%e7%a1%80"></a>
深度优先搜索理论基础
</h1><h2 id="两者大概的区别">
<a class="header-anchor" href="#%e4%b8%a4%e8%80%85%e5%a4%a7%e6%a6%82%e7%9a%84%e5%8c%ba%e5%88%ab"></a>
两者大概的区别：
</h2><ul>
<li>
<p>dfs是朝一个方向去搜，不到黄河不回头，直到遇到绝境了，搜不下去了，再换方向（换方向的过程就涉及到了回溯）。</p>
        
        <hr><p>本文2025-06-14首发于<a href='https://wittleLuna.github.io/'>wittleLuna的博客</a>，最后修改于2025-06-15</p>]]>
      </description>
      
        <category>算法</category>
      
    </item>
    
  </channel>
</rss>
